<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Visor EBP – Árbol interactivo</title>

  <style>
    :root{
      --bg:#f6f8fb;
      --card:#fff;
      --ink:#0f172a;
      --muted:#64748b;
      --line:#cbd5e1;
      --accent:#1d4ed8;

      --labelFont: 13px;        /* etiquetas inferiores */
      --sel:#0b2e4a;            /* azul oscuro selección */
      --nodeFont: 18px;         /* ✅ tamaño base nodo (más grande) */
    }

    html, body { height: 100%; overflow: hidden; }

    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:var(--bg);
      color:var(--ink);
    }

    header{
      padding:14px 16px;
      background:linear-gradient(90deg,#0b2e4a,#0b3a68);
      color:#fff;
    }
    header h1{margin:0;font-size:18px;font-weight:700}
    header p{margin:6px 0 0;font-size:12px;opacity:.9}

    .wrap{
      display:grid;
      grid-template-columns:320px 1fr;
      gap:12px;
      padding:12px;
      height:calc(100vh - 64px);
      box-sizing:border-box;
    }

    .panel{
      background:var(--card);
      border:1px solid #e2e8f0;
      border-radius:14px;
      box-shadow:0 1px 4px rgba(15,23,42,.06);
      overflow:auto;
    }
    .panel .inner{padding:12px;}

    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
    select,button{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid #e2e8f0;
      background:#fff;
      font-size:13px
    }
    button{
      cursor:pointer;
      background:#0ea5e9;
      color:#fff;
      border:0;
      font-weight:700
    }
    button:hover{filter:brightness(.95)}

    .small{font-size:12px;color:var(--muted);line-height:1.35}
    .chips{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
    .chip{
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      background:#eef2ff;
      border:1px solid #e0e7ff;
      color:#3730a3
    }
    .hint{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      background:#f1f5f9;
      border:1px dashed #cbd5e1;
      font-size:12px;
      color:#334155
    }

    #svgWrap{position:relative; overflow:hidden;}
    svg{
      width:100%;
      height:100%;
      display:block;
      background:var(--card);
      border:1px solid #e2e8f0;
      border-radius:14px;
      box-shadow:0 1px 4px rgba(15,23,42,.06);
    }

    .node rect{
      fill:#fff;
      stroke:#94a3b8;
      stroke-width:1.2;
      rx:10; ry:10
    }
    .node .title{
      font-size:var(--nodeFont);
      fill:#0f172a;
      font-weight:700;
    }
    .link{
      fill:none;
      stroke:#94a3b8;
      stroke-width:1.2;
      opacity:.9
    }
    .node:hover rect{
      stroke:var(--accent);
      stroke-width:2
    }

    /* Selección y ruta */
    .node.selected rect,
    .node.path rect{
      fill:var(--sel);
      stroke:var(--sel);
    }
    .node.selected .title,
    .node.path .title{
      fill:#fff;
    }
    .link.path{
      stroke:var(--sel);
      stroke-width:2.2;
      opacity:1;
    }

    @media(max-width:980px){
      .wrap{grid-template-columns:1fr; height:auto}
      svg{height:75vh}
    }

    /* etiquetas inferiores */
    .colLabels{
      position:absolute;
      left:0; right:0;
      bottom:0;
      pointer-events:none;
      z-index:10;
      height:0;
    }

    .colLabel{
      position:absolute;
      transform:translateX(-50%);
      display:flex;
      align-items:center;
      gap:8px;
      padding:9px 12px;
      border-radius:12px;
      background:#0f172a;
      color:#fff;
      font-size:var(--labelFont);
      font-weight:900;
      opacity:.93;
      box-shadow:0 6px 16px rgba(15,23,42,.18);
      max-width:360px;
      white-space:normal;
    }
    .colLabel b{
      background:rgba(255,255,255,.18);
      padding:2px 8px;
      border-radius:999px;
      font-size:calc(var(--labelFont) - 1px);
      font-weight:900;
      white-space:nowrap;
    }
    .colLabel span{
      white-space:normal;
      line-height:1.15;
      max-width:280px;
    }
  </style>
</head>

<body>
<header>
  <h1>Visor EBP</h1>
  <p>Estrategia de País del BID 2024 -2027 | Costa Rica</p>
</header>

<div class="wrap">
  <div class="panel">
    <div class="inner">
      <div class="small"><b>Niveles de lectura</b> (elige el orden de atributos)</div>

      <label>Nivel 1</label><select id="lvl1"></select>
      <label>Nivel 2</label><select id="lvl2"></select>
      <label>Nivel 3</label><select id="lvl3"></select>
      <label>Nivel 4</label><select id="lvl4"></select>
      <label>Nivel 5</label><select id="lvl5"></select>

      <div style="height:10px"></div>
      <button id="renderBtn">Renderizar</button>

      <div class="chips" id="orderChips"></div>

      <div class="hint">
        <b>Gestos:</b> arrastra para mover • rueda/trackpad para zoom • click en un nodo para ver detalle abajo.
      </div>

      <hr style="border:none;border-top:1px solid #e2e8f0;margin:12px 0">
      <div class="small"><b>Detalle (click en nodo)</b></div>
      <div id="detail" class="small" style="margin-top:8px;white-space:pre-wrap"></div>
    </div>
  </div>

  <div id="svgWrap">
    <div class="colLabels" id="colLabels"></div>
    <svg id="viz"></svg>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
/* =========================
   Config
========================= */
const NONE = "(Ninguno)";
const DEFAULT_LEVELS = ["Área Prioritaria","Objetivo Estratégico","Impacto Esperado", NONE, NONE];

// opciones (sin Año/Fuente)
const LABELS_ALLOWED = [
  "Área Prioritaria",
  "Objetivo Estratégico",
  "Impacto Esperado",
  "Operaciones vinculadas",
  "Cooperaciones técnicas vinculadas",
  "Indicador"
];
const LEVEL_OPTIONS = [NONE, ...LABELS_ALLOWED];

const lvlSelects = ["lvl1","lvl2","lvl3","lvl4","lvl5"].map(id=>document.getElementById(id));
const orderChips = document.getElementById("orderChips");
const detail = document.getElementById("detail");
const colLabelsEl = document.getElementById("colLabels");
const svgWrapEl = document.getElementById("svgWrap");

function fillSelect(select, options, selected){
  select.innerHTML = "";
  options.forEach(opt=>{
    const o=document.createElement("option");
    o.value=opt; o.textContent=opt;
    if(opt===selected) o.selected=true;
    select.appendChild(o);
  });
}
function updateChips(levelsActive){
  orderChips.innerHTML="";
  if(levelsActive.length === 0){
    const d=document.createElement("div");
    d.className="chip";
    d.textContent=`(sin niveles activos)`;
    orderChips.appendChild(d);
    return;
  }
  levelsActive.forEach((l,i)=>{
    const d=document.createElement("div");
    d.className="chip";
    d.textContent=`${i+1}. ${l}`;
    orderChips.appendChild(d);
  });
}

lvlSelects.forEach((sel,i)=>fillSelect(sel, LEVEL_OPTIONS, DEFAULT_LEVELS[i] || NONE));

async function loadRows(){
  const res = await fetch("./data.json");
  const data = await res.json();
  return data.rows;
}

function buildTree(rows, levelsActive){
  const root = {name:"EBP Costa Rica 2024-2027", children:[]};

  function getChild(parent, name){
    if(!parent.children) parent.children=[];
    let c = parent.children.find(x=>x.name===name);
    if(!c){ c={name, children:[], _rows:[]}; parent.children.push(c); }
    return c;
  }

  rows.forEach(r=>{
    let p=root;

    if(levelsActive.length === 0){
      root._rows = root._rows || [];
      root._rows.push(r);
      return;
    }

    levelsActive.forEach(lvl=>{
      let v = (r[lvl] ?? "").toString().trim();
      if(!v) v="(Sin dato)";
      p=getChild(p, v);
      p._rows.push(r);
    });
  });

  return root;
}

/* =========================
   SVG + Zoom
========================= */
const svg = d3.select("#viz");
let g = svg.append("g");

let ROOT_HIER = null;
let CURRENT_LEVELS_ACTIVE = [];
let NODE_CARD_WIDTH = 340;      /* ✅ más ancho para texto */
let COL_STEP_X = 480;           /* ✅ más separación columnas */

// base para reset
let BASE_POS = new Map();  // node -> {x,y}

/* ✅ Hacer que el texto escale con zoom (y tenga mínimo legible) */
function setNodeFontByZoom(k){
  const base = 18;             // igual que --nodeFont inicial
  const scaled = base * k;     // crece con zoom
  const clamped = Math.max(14, Math.min(28, scaled));
  document.documentElement.style.setProperty("--nodeFont", clamped.toFixed(1) + "px");
}

function setLabelFontByZoom(k){
  const base = 13;
  const scaled = base * k;
  const clamped = Math.max(10, Math.min(22, scaled));
  document.documentElement.style.setProperty("--labelFont", clamped.toFixed(1) + "px");
}

function renderColumnLabels(levelsActive){
  colLabelsEl.innerHTML = "";
  levelsActive.forEach((name, i)=>{
    const div = document.createElement("div");
    div.className = "colLabel";
    div.dataset.depth = String(i+1);
    div.innerHTML = `<b>N${i+1}</b><span>${name}</span>`;
    colLabelsEl.appendChild(div);
  });
}

function autoLiftLabels(){
  const labels = Array.from(colLabelsEl.querySelectorAll(".colLabel"))
    .filter(el => el.style.display !== "none");

  let maxH = 0;
  for(const el of labels){
    maxH = Math.max(maxH, el.getBoundingClientRect().height);
  }
  const safeBottom = 10;
  const lift = Math.ceil(maxH + safeBottom);
  colLabelsEl.style.bottom = `${lift}px`;
}

function positionColumnLabels(){
  if(!ROOT_HIER) return;

  const t = d3.zoomTransform(svg.node());

  setLabelFontByZoom(t.k);
  setNodeFontByZoom(t.k);  /* ✅ escala texto nodos */

  const svgRect  = svg.node().getBoundingClientRect();
  const wrapRect = svgWrapEl.getBoundingClientRect();
  const svgOffsetX = svgRect.left - wrapRect.left;

  const margin = 40;
  const visibleMinX = margin;
  const visibleMaxX = wrapRect.width - margin;

  const activeCount = CURRENT_LEVELS_ACTIVE.length;

  for(let depth=1; depth<=activeCount; depth++){
    const label = colLabelsEl.querySelector(`.colLabel[data-depth="${depth}"]`);
    if(!label) continue;

    const colCenterLayoutX = (depth * COL_STEP_X) + (NODE_CARD_WIDTH / 2);
    const screenX = t.applyX(colCenterLayoutX);
    const leftPx = svgOffsetX + screenX;

    if(leftPx < visibleMinX || leftPx > visibleMaxX){
      label.style.display = "none";
      continue;
    }
    label.style.display = "";
    label.style.left = `${leftPx}px`;
  }

  autoLiftLabels();
}

let zoom = d3.zoom()
  .scaleExtent([0.2, 2.8])
  .on("zoom", (event)=>{
    g.attr("transform", event.transform);
    positionColumnLabels();
  });
svg.call(zoom);

/* =========================
   Wrap texto
========================= */
function wrapText(selection, width){
  selection.each(function(){
    const text = d3.select(this);
    const words = text.text().split(/\s+/).filter(Boolean);
    text.text(null);

    let line = [];
    let lineNumber = 0;
    const lineHeight = 1.25;
    const x = text.attr("x");

    let tspan = text.append("tspan").attr("x", x).attr("y", 0).attr("dy", "0em");

    for (let i=0; i<words.length; i++){
      line.push(words[i]);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > width){
        line.pop();
        tspan.text(line.join(" "));
        line = [words[i]];
        tspan = text.append("tspan")
          .attr("x", x)
          .attr("y", 0)
          .attr("dy", (++lineNumber * lineHeight) + "em")
          .text(words[i]);
      }
    }
  });
}

/* =========================
   Selección / Reset
========================= */
function clearSelection(){
  g.selectAll(".node").classed("selected", false).classed("path", false);
  g.selectAll(".link").classed("path", false);
}

/* =========================
   Alinear columnas SIN perder orden
========================= */
function applyColumnAlignment(selectedNode){
  if(!selectedNode) return;

  let cur = selectedNode;
  const path = [];
  const byDepth = new Map();
  while(cur){
    path.push(cur);
    byDepth.set(cur.depth, cur);
    cur = cur.parent;
  }
  path.reverse();

  const baseSel = BASE_POS.get(selectedNode);
  const baseline = baseSel ? baseSel.x : selectedNode.x;

  const depthOffsets = new Map();
  ROOT_HIER.descendants().forEach(n=>{
    if(!depthOffsets.has(n.depth)) depthOffsets.set(n.depth, 0);
  });

  for(const [depth, nodeInPath] of byDepth.entries()){
    const b = BASE_POS.get(nodeInPath);
    if(!b) continue;
    depthOffsets.set(depth, baseline - b.x);
  }

  ROOT_HIER.descendants().forEach(n=>{
    const b = BASE_POS.get(n);
    const off = depthOffsets.get(n.depth) || 0;
    n._x = (b ? b.x : n.x) + off;
    n._y = (b ? b.y : n.y);
  });

  g.selectAll(".node")
    .transition().duration(520)
    .attr("transform", d => `translate(${d._y},${d._x})`);

  g.selectAll(".link")
    .transition().duration(520)
    .attr("d", d3.linkHorizontal()
      .x(d => d._y)
      .y(d => d._x)
    );
}

function resetToBaseLayout(){
  if(!ROOT_HIER) return;

  ROOT_HIER.descendants().forEach(n=>{
    const b = BASE_POS.get(n);
    n._x = b ? b.x : n.x;
    n._y = b ? b.y : n.y;
  });

  g.selectAll(".node")
    .transition().duration(380)
    .attr("transform", d => `translate(${d.y},${d.x})`);

  g.selectAll(".link")
    .transition().duration(380)
    .attr("d", d3.linkHorizontal().x(d=>d.y).y(d=>d.x));
}

/* =========================
   Zoom a ruta
========================= */
function zoomToPath(pathNodesArr){
  if(!pathNodesArr || pathNodesArr.length === 0) return;

  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;

  for(const n of pathNodesArr){
    const x = n._y ?? n.y;
    const y = n._x ?? n.x;
    const w = NODE_CARD_WIDTH;
    const h = (n.data._h || 70);

    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x + w);
    minY = Math.min(minY, y - h/2);
    maxY = Math.max(maxY, y + h/2);
  }

  const boundsW = maxX - minX;
  const boundsH = maxY - minY;

  const svgW = svg.node().clientWidth;
  const svgH = svg.node().clientHeight;

  const pad = 140;
  const scale = Math.min(2.6, Math.max(0.35,
    0.92 / Math.max(boundsW / (svgW - pad), boundsH / (svgH - pad))
  ));

  const midX = minX + boundsW/2;
  const midY = minY + boundsH/2;

  const translate = [
    svgW/2 - scale * midX,
    svgH/2 - scale * midY
  ];

  svg.transition().duration(650).call(
    zoom.transform,
    d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
  );
}

/* =========================
   Render
========================= */
function render(treeData){
  svg.selectAll("*").remove();
  g = svg.append("g");
  svg.call(zoom);

  const width = svg.node().clientWidth;
  const height = svg.node().clientHeight;

  ROOT_HIER = d3.hierarchy(treeData);

  const nodeCardWidth = NODE_CARD_WIDTH;
  const colGap = 140;
  COL_STEP_X = nodeCardWidth + colGap;

  const textWrapWidth = nodeCardWidth - 24;

  const rowGap = 150;
  const treeLayout = d3.tree().nodeSize([rowGap, 1]);
  treeLayout(ROOT_HIER);

  ROOT_HIER.descendants().forEach(d=>{
    d.y = d.depth * COL_STEP_X;
  });

  BASE_POS = new Map();
  ROOT_HIER.descendants().forEach(n=>{
    BASE_POS.set(n, {x:n.x, y:n.y});
    n._x = n.x; n._y = n.y;
  });

  g.selectAll(".link")
    .data(ROOT_HIER.links())
    .join("path")
    .attr("class","link")
    .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));

  const nodes = g.selectAll(".node")
    .data(ROOT_HIER.descendants())
    .join("g")
    .attr("class","node")
    .attr("transform", d => `translate(${d.y},${d.x})`)
    .on("click", (event,d)=>{
      event.stopPropagation();

      clearSelection();
      d3.select(event.currentTarget).classed("selected", true);

      let cur = d;
      const pathNodes = [];
      const pathSet = new Set();
      while(cur){
        pathNodes.push(cur);
        pathSet.add(cur);
        cur = cur.parent;
      }
      pathNodes.reverse();

      g.selectAll(".node").classed("path", n => pathSet.has(n));
      g.selectAll(".link").classed("path", l => pathSet.has(l.target));

      applyColumnAlignment(d);
      zoomToPath(pathNodes);

      const sample = (d.data._rows && d.data._rows[0]) ? d.data._rows[0] : null;
      const lines = [];
      lines.push(`Nodo: ${d.data.name}`);
      if(sample){
        lines.push("");
        lines.push("Ejemplo de fila asociada:");
        Object.keys(sample).forEach(k=>{
          if(["ID","ID_Area"].includes(k)) return;
          const v=(sample[k]??"").toString().trim();
          if(v) lines.push(`- ${k}: ${v}`);
        });
      }
      detail.textContent = lines.join("\n");
    });

  svg.on("click", ()=>{
    clearSelection();
    resetToBaseLayout();
  });

  nodes.append("rect")
    .attr("x", 0)
    .attr("y", -28)
    .attr("width", nodeCardWidth)
    .attr("height", 56);

  const title = nodes.append("text")
    .attr("class","title")
    .attr("x", 12)
    .attr("y", 0)
    .text(d=>d.data.name);

  title.call(wrapText, textWrapWidth);

  // centrado vertical real
  nodes.each(function(d){
    const node = d3.select(this);
    const textEl = node.select("text.title").node();
    const bbox = textEl.getBBox();

    const padY = 22;
    const h = bbox.height + padY * 2;
    d.data._h = h;

    node.select("rect")
      .attr("y", -(h/2))
      .attr("height", h);

    const centerShiftY = - (bbox.y + bbox.height / 2);
    node.select("text.title")
      .attr("transform", `translate(0, ${centerShiftY})`);
  });

  renderColumnLabels(CURRENT_LEVELS_ACTIVE);

  fitToView();
  function fitToView(){
    const bounds = g.node().getBBox();
    if (bounds.width === 0 || bounds.height === 0) return;

    const midX = bounds.x + bounds.width / 2;
    const midY = bounds.y + bounds.height / 2;

    const scale = 0.95 / Math.max(bounds.width / width, bounds.height / height);
    const translate = [width / 2 - scale * midX, height / 2 - scale * midY];

    svg.transition().duration(450).call(
      zoom.transform,
      d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
    ).on("end", ()=>positionColumnLabels());
  }

  setTimeout(positionColumnLabels, 480);
}

/* =========================
   UI niveles
========================= */
function getLevelsFromUI(){
  const levelsUI = lvlSelects.map(s=>s.value);

  const used = new Set();
  for(let i=0;i<levelsUI.length;i++){
    const v = levelsUI[i];
    if(v === NONE) continue;
    if(used.has(v)){
      levelsUI[i] = NONE;
      lvlSelects[i].value = NONE;
    } else {
      used.add(v);
    }
  }

  const active = levelsUI.filter(x => x !== NONE);
  updateChips(active);

  return { levelsUI, levelsActive: active };
}

let ROWS_CACHE=null;

async function main(){
  ROWS_CACHE = await loadRows();

  const {levelsActive} = getLevelsFromUI();
  CURRENT_LEVELS_ACTIVE = levelsActive;

  const tree = buildTree(ROWS_CACHE, CURRENT_LEVELS_ACTIVE);
  render(tree);
}
main();

document.getElementById("renderBtn").onclick = ()=>{
  const {levelsActive} = getLevelsFromUI();
  CURRENT_LEVELS_ACTIVE = levelsActive;

  const tree = buildTree(ROWS_CACHE, CURRENT_LEVELS_ACTIVE);
  render(tree);
};

window.addEventListener("resize", ()=>positionColumnLabels());
</script>
</body>
</html>
