<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Visor EBP – Árbol interactivo</title>

  <style>
    :root{
      --bg:#f3f6fb;
      --card:#ffffff;
      --ink:#0f172a;
      --muted:#64748b;
      --line:#cbd5e1;
      --accent:#1d4ed8;

      --sel:#0b2e4a;

      --labelFont: 14px;

      /* Tipografía de nodos (LEGIBLE) */
      --nodeFont: 30px;
      --nodeFontMin: 22px;
      --nodeFontMax: 44px;
    }

    html, body { height: 100%; overflow: hidden; }
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:var(--bg);
      color:var(--ink);
    }

    /* Encabezado */
    header{
      position:relative;
      padding:20px 16px;
      background:linear-gradient(180deg,#0a6b7f,#073a63);
      color:#fff;
      border-bottom:1px solid rgba(255,255,255,.10);
    }
    .headerCenter{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:18px;
      text-align:center;
      width:100%;
    }
    .logo{
      width:86px;
      height:86px;
      overflow:hidden;
      flex:0 0 auto;
      display:flex;
      align-items:center;
      justify-content:center;
      /* sin borde, sin recuadro */
      background:transparent;
      border:0;
      border-radius:0;
    }
    .logo img{
      width:100%;
      height:100%;
      object-fit:contain;
      display:block;
    }
    header h1{
      margin:0;
      font-size:52px;
      line-height:1.03;
      font-weight:950;
      letter-spacing:.2px;
    }
    header p{
      margin:8px 0 0;
      font-size:16px;
      opacity:.92;
    }

    .wrap{
      display:grid;
      grid-template-columns:360px 1fr;
      gap:12px;
      padding:12px;
      height:calc(100vh - 126px);
      box-sizing:border-box;
    }

    .panel{
      background:var(--card);
      border:1px solid #e2e8f0;
      border-radius:14px;
      box-shadow:0 1px 4px rgba(15,23,42,.06);
      overflow:auto;
    }
    .panel .inner{padding:12px;}

    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
    select,button{
      width:100%;
      padding:12px 12px;
      border-radius:12px;
      border:1px solid #e2e8f0;
      background:#fff;
      font-size:15px;
      box-sizing:border-box;
    }
    .btnPrimary{
      cursor:pointer;
      background:#0ea5e9;
      color:#fff;
      border:0;
      font-weight:900;
      padding:14px 12px;
      font-size:16px;
    }
    .btnPrimary:hover{filter:brightness(.96)}

    .btnSecondary{
      cursor:pointer;
      background:#0b2e4a;
      color:#fff;
      border:0;
      font-weight:900;
      padding:14px 12px;
      font-size:16px;
      border-radius:12px;
      width:100%;
      margin-top:10px;
    }
    .btnSecondary:hover{filter:brightness(.96)}

    .small{font-size:12px;color:var(--muted);line-height:1.35}

    .filtersBox{
      margin-top:12px;
      padding:12px;
      border-radius:14px;
      background:#f1f6fb;
      border:1px dashed #cbd5e1;
    }
    .filtersTitle{
      font-weight:900;
      color:#0f172a;
      margin-bottom:8px;
      font-size:16px;
    }
    .filtersBox label{margin-top:10px}

    #svgWrap{position:relative; overflow:hidden;}
    svg{
      width:100%;
      height:100%;
      display:block;
      background:var(--card);
      border:1px solid #e2e8f0;
      border-radius:14px;
      box-shadow:0 1px 4px rgba(15,23,42,.06);
    }

    .node rect{
      fill:#fff;
      stroke:#94a3b8;
      stroke-width:1.2;
      rx:16; ry:16;
    }
    .node .title{
      font-size:var(--nodeFont);
      fill:#0f172a;
      font-weight:900;
    }
    .link{
      fill:none;
      stroke:#94a3b8;
      stroke-width:1.2;
      opacity:.9
    }
    .node:hover rect{
      stroke:var(--accent);
      stroke-width:2
    }

    .node.selected rect,
    .node.path rect{
      fill:var(--sel);
      stroke:var(--sel);
    }
    .node.selected .title,
    .node.path .title{
      fill:#fff;
    }
    .link.path{
      stroke:var(--sel);
      stroke-width:2.4;
      opacity:1;
    }

    @media(max-width:980px){
      .wrap{grid-template-columns:1fr; height:auto}
      svg{height:75vh}
      header h1{font-size:36px}
      header p{font-size:14px}
      .logo{width:70px;height:70px}
    }

    /* Etiquetas de columnas */
    .colLabels{
      position:absolute;
      left:0; right:0;
      bottom:0;
      pointer-events:none;
      z-index:10;
      height:0;
    }
    .colLabel{
      position:absolute;
      transform:translateX(-50%);
      display:flex;
      align-items:center;
      gap:8px;
      padding:10px 14px;
      border-radius:12px;
      background:#0f172a;
      color:#fff;
      font-size:var(--labelFont);
      font-weight:900;
      opacity:.93;
      box-shadow:0 6px 16px rgba(15,23,42,.18);
      max-width:420px;
      white-space:normal;
    }
    .colLabel b{
      background:rgba(255,255,255,.18);
      padding:2px 10px;
      border-radius:999px;
      font-size:calc(var(--labelFont) - 1px);
      font-weight:900;
      white-space:nowrap;
    }
    .colLabel span{
      white-space:normal;
      line-height:1.15;
      max-width:340px;
    }
  </style>
</head>

<body>
<header>
  <div class="headerCenter">
    <div class="logo" title="BID">
      <img src="https://portales.sre.gob.mx/dgvosc/images/phocagallery/bid.png" alt="Logo BID">
    </div>
    <div>
      <h1>Visor EBP</h1>
      <p>Estrategia de País del BID 2024 -2027 | Costa Rica</p>
    </div>
  </div>
</header>

<div class="wrap">
  <div class="panel">
    <div class="inner">
      <div class="small"><b>Niveles de lectura</b> (elige el orden de atributos)</div>

      <label>Nivel 1</label><select id="lvl1"></select>
      <label>Nivel 2</label><select id="lvl2"></select>
      <label>Nivel 3</label><select id="lvl3"></select>
      <label>Nivel 4</label><select id="lvl4"></select>
      <label>Nivel 5</label><select id="lvl5"></select>

      <div style="height:10px"></div>
      <button class="btnPrimary" id="renderBtn">Renderizar</button>

      <div class="filtersBox" style="margin-top:14px;">
        <div class="filtersTitle">Filtros</div>

        <label>Operación vinculada</label>
        <select id="fOp"></select>

        <label>Área Prioritaria</label>
        <select id="fArea"></select>

        <label>Objetivo Estratégico</label>
        <select id="fObj"></select>

        <button class="btnSecondary" id="applyFiltersBtn">Aplicar filtros y renderizar</button>
        <button class="btnSecondary" style="background:#334155" id="resetBtn">Reestablecer</button>
      </div>
    </div>
  </div>

  <div id="svgWrap">
    <div class="colLabels" id="colLabels"></div>
    <svg id="viz"></svg>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
const NONE = "(Ninguno)";
const ALL  = "(Todos)";

/* Precarga:
   Nivel 1: Área Prioritaria
   Nivel 2: Objetivo Estratégico
   3-5: Ninguno
*/
const DEFAULT_LEVELS = ["Área Prioritaria","Objetivo Estratégico", NONE, NONE, NONE];

/* Sin Año/Fuente */
const LABELS_ALLOWED = [
  "Área Prioritaria",
  "Objetivo Estratégico",
  "Impacto Esperado",
  "Operaciones vinculadas",
  "Cooperaciones técnicas vinculadas",
  "Indicador"
];
const LEVEL_OPTIONS = [NONE, ...LABELS_ALLOWED];

const lvlSelects = ["lvl1","lvl2","lvl3","lvl4","lvl5"].map(id=>document.getElementById(id));

const fOp   = document.getElementById("fOp");
const fArea = document.getElementById("fArea");
const fObj  = document.getElementById("fObj");

const colLabelsEl = document.getElementById("colLabels");
const svgWrapEl = document.getElementById("svgWrap");

function fillSelect(select, options, selected){
  select.innerHTML = "";
  options.forEach(opt=>{
    const o=document.createElement("option");
    o.value=opt; o.textContent=opt;
    if(opt===selected) o.selected=true;
    select.appendChild(o);
  });
}

lvlSelects.forEach((sel,i)=>fillSelect(sel, LEVEL_OPTIONS, DEFAULT_LEVELS[i] || NONE));

async function loadRows(){
  const res = await fetch("./data.json");
  const data = await res.json();
  return data.rows;
}

/* ---- Filtros mutuamente “dependientes” (cascada) ---- */
function uniqSorted(arr){
  return Array.from(new Set(arr.filter(Boolean))).sort((a,b)=>a.localeCompare(b,'es',{sensitivity:'base'}));
}

function getCurrentFilterState(){
  return {
    op: fOp.value || ALL,
    area: fArea.value || ALL,
    obj: fObj.value || ALL
  };
}

function rowsMatchingFilters(rows, st){
  return rows.filter(r=>{
    const opV   = (r["Operaciones vinculadas"] ?? "").toString().trim() || "(Sin dato)";
    const areaV = (r["Área Prioritaria"] ?? "").toString().trim() || "(Sin dato)";
    const objV  = (r["Objetivo Estratégico"] ?? "").toString().trim() || "(Sin dato)";

    if(st.op   !== ALL && opV   !== st.op)   return false;
    if(st.area !== ALL && areaV !== st.area) return false;
    if(st.obj  !== ALL && objV  !== st.obj)  return false;
    return true;
  });
}

/* Rellena combos en cascada (lo que elijas filtra los otros listados) */
function refreshFilterOptions(rows){
  const st = getCurrentFilterState();

  const stForOp = {op: ALL, area: st.area, obj: st.obj};
  const rowsForOp = rowsMatchingFilters(rows, stForOp);
  const ops = uniqSorted(rowsForOp.map(r => ((r["Operaciones vinculadas"] ?? "").toString().trim() || "(Sin dato)")));

  const stForArea = {op: st.op, area: ALL, obj: st.obj};
  const rowsForArea = rowsMatchingFilters(rows, stForArea);
  const areas = uniqSorted(rowsForArea.map(r => ((r["Área Prioritaria"] ?? "").toString().trim() || "(Sin dato)")));

  const stForObj = {op: st.op, area: st.area, obj: ALL};
  const rowsForObj = rowsMatchingFilters(rows, stForObj);
  const objs = uniqSorted(rowsForObj.map(r => ((r["Objetivo Estratégico"] ?? "").toString().trim() || "(Sin dato)")));

  const opVal   = ops.includes(st.op)   ? st.op   : ALL;
  const areaVal = areas.includes(st.area)? st.area: ALL;
  const objVal  = objs.includes(st.obj) ? st.obj  : ALL;

  fillSelect(fOp,   [ALL, ...ops],   opVal);
  fillSelect(fArea, [ALL, ...areas], areaVal);
  fillSelect(fObj,  [ALL, ...objs],  objVal);
}

function getLevelsActiveFromUI(){
  const raw = lvlSelects.map(s=>s.value);
  const active = raw.filter(v => v !== NONE);
  const used = new Set();
  const fixed = [];
  for(const v of active){
    if(!used.has(v)){
      used.add(v);
      fixed.push(v);
    }
  }
  return fixed;
}

/* ---- Árbol ---- */
function buildTree(rows, levelsActive){
  const root = {name:"EBP Costa Rica 2024-2027", children:[]};

  function getChild(parent, name){
    if(!parent.children) parent.children=[];
    let c = parent.children.find(x=>x.name===name);
    if(!c){ c={name, children:[], _rows:[]}; parent.children.push(c); }
    return c;
  }

  rows.forEach(r=>{
    let p=root;

    if(levelsActive.length === 0){
      root._rows = root._rows || [];
      root._rows.push(r);
      return;
    }

    levelsActive.forEach(lvl=>{
      let v = (r[lvl] ?? "").toString().trim();
      if(!v) v="(Sin dato)";
      p=getChild(p, v);
      p._rows.push(r);
    });
  });

  return root;
}

const svg = d3.select("#viz");
let g = svg.append("g");

let ROOT_HIER = null;
let CURRENT_LEVELS_ACTIVE = [];
let ROWS_CACHE = null;

let NODE_CARD_WIDTH = 760;     // más ancho para evitar “recortes”
let COL_STEP_X = 980;          // separación por columna
let BASE_POS = new Map();

function setNodeFontByZoom(k){
  const base = 30;
  const scaled = base * k;
  const min = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--nodeFontMin")) || 20;
  const max = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--nodeFontMax")) || 44;
  const clamped = Math.max(min, Math.min(max, scaled));
  document.documentElement.style.setProperty("--nodeFont", clamped.toFixed(1) + "px");
}
function setLabelFontByZoom(k){
  const base = 14;
  const scaled = base * k;
  const clamped = Math.max(12, Math.min(24, scaled));
  document.documentElement.style.setProperty("--labelFont", clamped.toFixed(1) + "px");
}

function renderColumnLabels(levelsActive){
  colLabelsEl.innerHTML = "";
  levelsActive.forEach((name, i)=>{
    const div = document.createElement("div");
    div.className = "colLabel";
    div.dataset.depth = String(i+1);
    div.innerHTML = `<b>N${i+1}</b><span>${name}</span>`;
    colLabelsEl.appendChild(div);
  });
}
function autoLiftLabels(){
  const labels = Array.from(colLabelsEl.querySelectorAll(".colLabel"))
    .filter(el => el.style.display !== "none");

  let maxH = 0;
  for(const el of labels){
    maxH = Math.max(maxH, el.getBoundingClientRect().height);
  }
  colLabelsEl.style.bottom = `${Math.ceil(maxH + 10)}px`;
}
function positionColumnLabels(){
  if(!ROOT_HIER) return;

  const t = d3.zoomTransform(svg.node());
  setLabelFontByZoom(t.k);
  setNodeFontByZoom(t.k);

  const svgRect  = svg.node().getBoundingClientRect();
  const wrapRect = svgWrapEl.getBoundingClientRect();
  const svgOffsetX = svgRect.left - wrapRect.left;

  const margin = 40;
  const visibleMinX = margin;
  const visibleMaxX = wrapRect.width - margin;

  const activeCount = CURRENT_LEVELS_ACTIVE.length;

  for(let depth=1; depth<=activeCount; depth++){
    const label = colLabelsEl.querySelector(`.colLabel[data-depth="${depth}"]`);
    if(!label) continue;

    const colCenterLayoutX = (depth * COL_STEP_X) + (NODE_CARD_WIDTH / 2);
    const screenX = t.applyX(colCenterLayoutX);
    const leftPx = svgOffsetX + screenX;

    if(leftPx < visibleMinX || leftPx > visibleMaxX){
      label.style.display = "none";
      continue;
    }
    label.style.display = "";
    label.style.left = `${leftPx}px`;
  }

  autoLiftLabels();
}

let zoom = d3.zoom()
  .scaleExtent([0.25, 3.2])
  .on("zoom", (event)=>{
    g.attr("transform", event.transform);
    positionColumnLabels();
  });
svg.call(zoom);

function wrapText(selection, width){
  selection.each(function(){
    const text = d3.select(this);
    const words = text.text().split(/\s+/).filter(Boolean);
    text.text(null);

    let line = [];
    let lineNumber = 0;
    const lineHeight = 1.18;
    const x = text.attr("x");

    let tspan = text.append("tspan").attr("x", x).attr("y", 0).attr("dy", "0em");

    for (let i=0; i<words.length; i++){
      line.push(words[i]);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > width){
        line.pop();
        tspan.text(line.join(" "));
        line = [words[i]];
        tspan = text.append("tspan")
          .attr("x", x)
          .attr("y", 0)
          .attr("dy", (++lineNumber * lineHeight) + "em")
          .text(words[i]);
      }
    }
  });
}

function clearSelection(){
  g.selectAll(".node").classed("selected", false).classed("path", false);
  g.selectAll(".link").classed("path", false);
}

function applyColumnAlignment(selectedNode){
  if(!selectedNode) return;

  let cur = selectedNode;
  const byDepth = new Map();
  while(cur){
    byDepth.set(cur.depth, cur);
    cur = cur.parent;
  }

  const baseSel = BASE_POS.get(selectedNode);
  const baseline = baseSel ? baseSel.x : selectedNode.x;

  const depthOffsets = new Map();
  ROOT_HIER.descendants().forEach(n=>{
    if(!depthOffsets.has(n.depth)) depthOffsets.set(n.depth, 0);
  });

  for(const [depth, nodeInPath] of byDepth.entries()){
    const b = BASE_POS.get(nodeInPath);
    if(!b) continue;
    depthOffsets.set(depth, baseline - b.x);
  }

  ROOT_HIER.descendants().forEach(n=>{
    const b = BASE_POS.get(n);
    const off = depthOffsets.get(n.depth) || 0;
    n._x = (b ? b.x : n.x) + off;
    n._y = (b ? b.y : n.y);
  });

  g.selectAll(".node")
    .transition().duration(520)
    .attr("transform", d => `translate(${d._y},${d._x})`);

  g.selectAll(".link")
    .transition().duration(520)
    .attr("d", d3.linkHorizontal().x(d => d._y).y(d => d._x));
}

function resetToBaseLayout(){
  if(!ROOT_HIER) return;

  ROOT_HIER.descendants().forEach(n=>{
    const b = BASE_POS.get(n);
    n._x = b ? b.x : n.x;
    n._y = b ? b.y : n.y;
  });

  g.selectAll(".node")
    .transition().duration(380)
    .attr("transform", d => `translate(${d.y},${d.x})`);

  g.selectAll(".link")
    .transition().duration(380)
    .attr("d", d3.linkHorizontal().x(d=>d.y).y(d=>d.x));
}

function zoomToPath(pathNodesArr){
  if(!pathNodesArr || pathNodesArr.length === 0) return;

  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;

  for(const n of pathNodesArr){
    const x = n._y ?? n.y;
    const y = n._x ?? n.x;
    const w = NODE_CARD_WIDTH;
    const h = (n.data._h || 160);

    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x + w);
    minY = Math.min(minY, y - h/2);
    maxY = Math.max(maxY, y + h/2);
  }

  const boundsW = maxX - minX;
  const boundsH = maxY - minY;

  const svgW = svg.node().clientWidth;
  const svgH = svg.node().clientHeight;

  const pad = 240;
  const scale = Math.min(2.4, Math.max(0.45,
    0.95 / Math.max(boundsW / (svgW - pad), boundsH / (svgH - pad))
  ));

  const midX = minX + boundsW/2;
  const midY = minY + boundsH/2;

  const translate = [
    svgW/2 - scale * midX,
    svgH/2 - scale * midY
  ];

  svg.transition().duration(650).call(
    zoom.transform,
    d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
  );
}

/* ✅ CLAVE para tu problema:
   Al renderizar, hacemos "fit to view" PERO sin acercar de más.
   (nunca escala > 1) => sale como tu “segunda imagen”, y luego zoom con mouse.
*/
function fitToViewNoOverZoom(){
  const bounds = g.node().getBBox();
  if (bounds.width === 0 || bounds.height === 0) return;

  const svgW = svg.node().clientWidth;
  const svgH = svg.node().clientHeight;

  const midX = bounds.x + bounds.width / 2;
  const midY = bounds.y + bounds.height / 2;

  const scaleFit = 0.92 / Math.max(bounds.width / svgW, bounds.height / svgH);
  const scale = Math.min(scaleFit, 1);   // ✅ NO acercar más de 1

  const translate = [svgW / 2 - scale * midX, svgH / 2 - scale * midY];

  svg.transition().duration(450).call(
    zoom.transform,
    d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
  ).on("end", ()=>{
    positionColumnLabels();
    const k = d3.zoomTransform(svg.node()).k;
    setNodeFontByZoom(k);
  });
}

function render(treeData){
  svg.selectAll("*").remove();
  g = svg.append("g");
  svg.call(zoom);

  ROOT_HIER = d3.hierarchy(treeData);

  const colGap = 220;
  COL_STEP_X = NODE_CARD_WIDTH + colGap;
  const textWrapWidth = NODE_CARD_WIDTH - 48;

  /* Más compacto en vertical (reduce “huecos amarillos”) */
  const rowGap = 200;

  const treeLayout = d3.tree().nodeSize([rowGap, 1]);
  treeLayout(ROOT_HIER);

  /* columnas fijas por nivel */
  ROOT_HIER.descendants().forEach(d=>{
    d.y = d.depth * COL_STEP_X;
  });

  BASE_POS = new Map();
  ROOT_HIER.descendants().forEach(n=>{
    BASE_POS.set(n, {x:n.x, y:n.y});
    n._x = n.x; n._y = n.y;
  });

  g.selectAll(".link")
    .data(ROOT_HIER.links())
    .join("path")
    .attr("class","link")
    .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));

  const nodes = g.selectAll(".node")
    .data(ROOT_HIER.descendants())
    .join("g")
    .attr("class","node")
    .attr("transform", d => `translate(${d.y},${d.x})`)
    .on("click", (event,d)=>{
      event.stopPropagation();

      clearSelection();
      d3.select(event.currentTarget).classed("selected", true);

      let cur = d;
      const pathNodes = [];
      const pathSet = new Set();
      while(cur){
        pathNodes.push(cur);
        pathSet.add(cur);
        cur = cur.parent;
      }
      pathNodes.reverse();

      g.selectAll(".node").classed("path", n => pathSet.has(n));
      g.selectAll(".link").classed("path", l => pathSet.has(l.target));

      applyColumnAlignment(d);
      zoomToPath(pathNodes);
    });

  svg.on("click", ()=>{
    clearSelection();
    resetToBaseLayout();
  });

  nodes.append("rect")
    .attr("x", 0)
    .attr("y", -70)
    .attr("width", NODE_CARD_WIDTH)
    .attr("height", 140);

  const title = nodes.append("text")
    .attr("class","title")
    .attr("x", 26)
    .attr("y", 0)
    .text(d=>d.data.name);

  title.call(wrapText, textWrapWidth);

  /* Ajustar alto y centrar vertical el texto */
  nodes.each(function(d){
    const node = d3.select(this);
    const textEl = node.select("text.title").node();
    const bbox = textEl.getBBox();

    const padY = 34;
    const h = bbox.height + padY * 2;
    d.data._h = h;

    node.select("rect")
      .attr("y", -(h/2))
      .attr("height", h);

    const centerShiftY = - (bbox.y + bbox.height / 2);
    node.select("text.title")
      .attr("transform", `translate(0, ${centerShiftY})`);
  });

  renderColumnLabels(CURRENT_LEVELS_ACTIVE);

  /* ✅ salida “como la segunda imagen” */
  fitToViewNoOverZoom();

  setTimeout(positionColumnLabels, 520);
}

/* ---- Aplicación (render + filtros) ---- */
function applyAll(){
  const st = getCurrentFilterState();
  const filteredRows = rowsMatchingFilters(ROWS_CACHE, st);

  CURRENT_LEVELS_ACTIVE = getLevelsActiveFromUI();
  const tree = buildTree(filteredRows, CURRENT_LEVELS_ACTIVE);
  clearSelection();
  render(tree);
}

/* Eventos de filtros (cascada) */
function bindFilterEvents(){
  [fOp, fArea, fObj].forEach(sel=>{
    sel.addEventListener("change", ()=>{
      refreshFilterOptions(ROWS_CACHE);
    });
  });
}

document.getElementById("renderBtn").onclick = ()=>{
  clearSelection();
  applyAll();
};

document.getElementById("applyFiltersBtn").onclick = ()=>{
  clearSelection();
  applyAll();
};

document.getElementById("resetBtn").onclick = ()=>{
  /* reset niveles */
  lvlSelects.forEach((sel,i)=>fillSelect(sel, LEVEL_OPTIONS, DEFAULT_LEVELS[i] || NONE));

  /* reset filtros */
  fillSelect(fOp,   [ALL], ALL);
  fillSelect(fArea, [ALL], ALL);
  fillSelect(fObj,  [ALL], ALL);

  refreshFilterOptions(ROWS_CACHE);
  clearSelection();
  applyAll();
};

window.addEventListener("resize", ()=>{
  positionColumnLabels();
});

/* ---- Inicio ---- */
(async function main(){
  ROWS_CACHE = await loadRows();

  /* filtros iniciales */
  fillSelect(fOp,   [ALL], ALL);
  fillSelect(fArea, [ALL], ALL);
  fillSelect(fObj,  [ALL], ALL);
  refreshFilterOptions(ROWS_CACHE);
  bindFilterEvents();

  /* primer render */
  applyAll();
})();
</script>
</body>
</html>

