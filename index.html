<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Visor EBP – Árbol interactivo</title>

  <style>
    :root{
      --bg:#f6f8fb;
      --card:#fff;
      --ink:#0f172a;
      --muted:#64748b;
      --line:#cbd5e1;
      --accent:#1d4ed8;

      --labelFont: 14px;
      --sel:#0b2e4a;

      /* tipografía nodos */
      --nodeFont: 34px;
      --nodeFontMin: 34px;
      --nodeFontMax: 52px;
    }

    html, body { height: 100%; overflow: hidden; }
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:var(--bg);
      color:var(--ink);
    }

    header{
      position:relative;
      padding:22px 16px;
      background:linear-gradient(90deg,#0b2e4a,#0b3a68);
      color:#fff;
      border-bottom:1px solid rgba(255,255,255,.12);
    }
    .headerCenter{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:16px;
      text-align:center;
      width:100%;
    }
    .logo{
      width:64px;height:64px;border-radius:14px;
      background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.14);
      overflow:hidden;flex:0 0 auto;
      display:flex;align-items:center;justify-content:center;
    }
    .logo img{
      width:100%;height:100%;object-fit:contain;
      padding:10px;box-sizing:border-box;display:block;
    }
    header h1{
      margin:0;
      font-size:44px;
      line-height:1.03;
      font-weight:950;
      letter-spacing:.2px;
    }
    header p{margin:8px 0 0;font-size:16px;opacity:.92}

    .wrap{
      display:grid;
      grid-template-columns:360px 1fr;
      gap:12px;
      padding:12px;
      height:calc(100vh - 116px);
      box-sizing:border-box;
    }

    .panel{
      background:var(--card);
      border:1px solid #e2e8f0;
      border-radius:14px;
      box-shadow:0 1px 4px rgba(15,23,42,.06);
      overflow:auto;
    }
    .panel .inner{padding:12px;}

    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
    select,button{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid #e2e8f0;
      background:#fff;
      font-size:13px
    }
    button{
      cursor:pointer;background:#0ea5e9;color:#fff;border:0;font-weight:800
    }
    button:hover{filter:brightness(.95)}

    .small{font-size:12px;color:var(--muted);line-height:1.35}
    .chips{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
    .chip{
      font-size:11px;padding:4px 8px;border-radius:999px;
      background:#eef2ff;border:1px solid #e0e7ff;color:#3730a3
    }

    .hint{
      margin-top:10px;
      padding:12px;
      border-radius:12px;
      background:#f1f5f9;
      border:1px dashed #cbd5e1;
      font-size:12px;
      color:#334155
    }
    .hint b{display:block;margin-bottom:6px}

    .filtersRow{display:grid;grid-template-columns:1fr;gap:10px;margin-top:6px}
    .hintBtn{
      padding:10px 12px;
      border-radius:10px;
      border:0;
      background:#0b2e4a;
      color:#fff;
      font-weight:900;
      cursor:pointer;
      width:100%;
    }
    .hintBtn:hover{filter:brightness(.95)}

    #svgWrap{position:relative; overflow:hidden;}
    svg{
      width:100%;height:100%;display:block;
      background:var(--card);
      border:1px solid #e2e8f0;border-radius:14px;
      box-shadow:0 1px 4px rgba(15,23,42,.06);
    }

    .node rect{
      fill:#fff;stroke:#94a3b8;stroke-width:1.2;
      rx:14;ry:14;
    }
    .node .title{
      font-size:var(--nodeFont);
      fill:#0f172a;
      font-weight:900;
    }
    .link{fill:none;stroke:#94a3b8;stroke-width:1.2;opacity:.9}
    .node:hover rect{stroke:var(--accent);stroke-width:2}

    .node.selected rect,
    .node.path rect{fill:var(--sel);stroke:var(--sel);}
    .node.selected .title,
    .node.path .title{fill:#fff;}
    .link.path{stroke:var(--sel);stroke-width:2.4;opacity:1;}

    @media(max-width:980px){
      .wrap{grid-template-columns:1fr; height:auto}
      svg{height:75vh}
      header h1{font-size:34px}
      header p{font-size:14px}
      .logo{width:54px;height:54px}
    }

    .colLabels{
      position:absolute;left:0;right:0;bottom:0;
      pointer-events:none;z-index:10;height:0;
    }
    .colLabel{
      position:absolute;transform:translateX(-50%);
      display:flex;align-items:center;gap:8px;
      padding:10px 14px;border-radius:12px;
      background:#0f172a;color:#fff;
      font-size:var(--labelFont);font-weight:900;
      opacity:.93;
      box-shadow:0 6px 16px rgba(15,23,42,.18);
      max-width:520px;white-space:normal;
    }
    .colLabel b{
      background:rgba(255,255,255,.18);
      padding:2px 10px;border-radius:999px;
      font-size:calc(var(--labelFont) - 1px);
      font-weight:900;white-space:nowrap;
    }
    .colLabel span{white-space:normal;line-height:1.15;max-width:420px;}
  </style>
</head>

<body>
<header>
  <div class="headerCenter">
    <div class="logo" title="BID">
      <img src="https://portales.sre.gob.mx/dgvosc/images/phocagallery/bid.png" alt="Logo BID">
    </div>
    <div>
      <h1>Visor EBP</h1>
      <p>Estrategia de País del BID 2024 -2027 | Costa Rica</p>
    </div>
  </div>
</header>

<div class="wrap">
  <div class="panel">
    <div class="inner">
      <div class="small"><b>Niveles de lectura</b> (elige el orden de atributos)</div>

      <label>Nivel 1</label><select id="lvl1"></select>
      <label>Nivel 2</label><select id="lvl2"></select>
      <label>Nivel 3</label><select id="lvl3"></select>
      <label>Nivel 4</label><select id="lvl4"></select>
      <label>Nivel 5</label><select id="lvl5"></select>

      <div style="height:10px"></div>
      <button id="renderBtn">Renderizar</button>

      <div class="chips" id="orderChips"></div>

      <!-- ✅ Caja tipo "Gestos" pero para FILTROS -->
      <div class="hint" style="margin-top:12px">
        <b>Filtros</b>
        <div class="filtersRow">
          <div>
            <label style="margin:0 0 6px">Operación vinculada</label>
            <select id="fOperacion"></select>
          </div>
          <div>
            <label style="margin:0 0 6px">Área Prioritaria</label>
            <select id="fArea"></select>
          </div>
          <div>
            <label style="margin:0 0 6px">Objetivo Estratégico</label>
            <select id="fObjetivo"></select>
          </div>
          <button class="hintBtn" id="applyFiltersBtn">Aplicar filtros y renderizar</button>
        </div>

        <div style="margin-top:10px">
          <span style="font-weight:700">Gestos:</span>
          arrastra para mover • rueda/trackpad para zoom • click en un nodo para resaltar ruta.
        </div>
      </div>
    </div>
  </div>

  <div id="svgWrap">
    <div class="colLabels" id="colLabels"></div>
    <svg id="viz"></svg>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
/* =========================
   CONFIG NIVELES
========================= */
const NONE = "(Ninguno)";
const DEFAULT_LEVELS = ["Área Prioritaria","Objetivo Estratégico", NONE, NONE, NONE];

const LABELS_ALLOWED = [
  "Área Prioritaria",
  "Objetivo Estratégico",
  "Impacto Esperado",
  "Operaciones vinculadas",
  "Cooperaciones técnicas vinculadas",
  "Indicador"
];
const LEVEL_OPTIONS = [NONE, ...LABELS_ALLOWED];

const lvlSelects = ["lvl1","lvl2","lvl3","lvl4","lvl5"].map(id=>document.getElementById(id));
const orderChips = document.getElementById("orderChips");
const colLabelsEl = document.getElementById("colLabels");
const svgWrapEl = document.getElementById("svgWrap");

function fillSelect(select, options, selected){
  select.innerHTML = "";
  options.forEach(opt=>{
    const o=document.createElement("option");
    o.value=opt; o.textContent=opt;
    if(opt===selected) o.selected=true;
    select.appendChild(o);
  });
}
lvlSelects.forEach((sel,i)=>fillSelect(sel, LEVEL_OPTIONS, DEFAULT_LEVELS[i] || NONE));

function updateChips(levelsActive){
  orderChips.innerHTML="";
  if(levelsActive.length === 0){
    const d=document.createElement("div");
    d.className="chip";
    d.textContent=`(sin niveles activos)`;
    orderChips.appendChild(d);
    return;
  }
  levelsActive.forEach((l,i)=>{
    const d=document.createElement("div");
    d.className="chip";
    d.textContent=`${i+1}. ${l}`;
    orderChips.appendChild(d);
  });
}

function getLevelsFromUI(){
  const raw = lvlSelects.map(s=>s.value);
  const active = raw.filter(v => v !== NONE);

  // sin duplicados, preservando orden
  const used = new Set();
  const fixed = [];
  for(const v of active){
    if(!used.has(v)){ used.add(v); fixed.push(v); }
  }
  updateChips(fixed);
  return fixed;
}

/* =========================
   FILTROS
========================= */
const fOperacion = document.getElementById("fOperacion");
const fArea = document.getElementById("fArea");
const fObjetivo = document.getElementById("fObjetivo");
const applyFiltersBtn = document.getElementById("applyFiltersBtn");

const FILTER_ANY = "(Todos)";

function uniqSorted(arr){
  return Array.from(new Set(arr.filter(Boolean))).sort((a,b)=>a.localeCompare(b,"es"));
}

function fillFilterSelect(sel, values){
  const opts = [FILTER_ANY, ...values];
  sel.innerHTML = "";
  opts.forEach(v=>{
    const o = document.createElement("option");
    o.value = v;
    o.textContent = v;
    sel.appendChild(o);
  });
  sel.value = FILTER_ANY;
}

function normalizeVal(v){
  const s = (v ?? "").toString().trim();
  return s ? s : "(Sin dato)";
}

function applyRowFilters(rows){
  const op = fOperacion.value;
  const ar = fArea.value;
  const ob = fObjetivo.value;

  return rows.filter(r=>{
    const vOp = normalizeVal(r["Operaciones vinculadas"]);
    const vAr = normalizeVal(r["Área Prioritaria"]);
    const vOb = normalizeVal(r["Objetivo Estratégico"]);

    if(op !== FILTER_ANY && vOp !== op) return false;
    if(ar !== FILTER_ANY && vAr !== ar) return false;
    if(ob !== FILTER_ANY && vOb !== ob) return false;
    return true;
  });
}

/* =========================
   DATA
========================= */
async function loadRows(){
  const res = await fetch("./data.json");
  const data = await res.json();
  return data.rows;
}

function buildTree(rows, levelsActive){
  const root = {name:"EBP Costa Rica 2024-2027", children:[]};

  function getChild(parent, name){
    if(!parent.children) parent.children=[];
    let c = parent.children.find(x=>x.name===name);
    if(!c){ c={name, children:[], _rows:[]}; parent.children.push(c); }
    return c;
  }

  rows.forEach(r=>{
    let p=root;

    if(levelsActive.length === 0){
      root._rows = root._rows || [];
      root._rows.push(r);
      return;
    }

    levelsActive.forEach(lvl=>{
      let v = (r[lvl] ?? "").toString().trim();
      if(!v) v="(Sin dato)";
      p=getChild(p, v);
      p._rows.push(r);
    });
  });

  return root;
}

/* =========================
   D3 RENDER (NODOS AUTO-ANCHO)
========================= */
const svg = d3.select("#viz");
let g = svg.append("g");

let ROOT_HIER = null;
let CURRENT_LEVELS_ACTIVE = [];
let BASE_POS = new Map();

const PAD_X = 26;
const PAD_Y = 30;
const MIN_W = 520;
const MAX_W = 980;
const COL_GAP = 220;
const ROW_GAP = 320;

let COL_WIDTHS = [];
let COL_OFFSETS = [];

function setNodeFontByZoom(k){
  const base = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--nodeFont")) || 34;
  const min = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--nodeFontMin")) || 34;
  const max = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--nodeFontMax")) || 52;
  const clamped = Math.max(min, Math.min(max, base * k));
  document.documentElement.style.setProperty("--nodeFont", clamped.toFixed(1) + "px");
}
function setLabelFontByZoom(k){
  const base = 14;
  const scaled = base * k;
  const clamped = Math.max(12, Math.min(24, scaled));
  document.documentElement.style.setProperty("--labelFont", clamped.toFixed(1) + "px");
}

function renderColumnLabels(levelsActive){
  colLabelsEl.innerHTML = "";
  levelsActive.forEach((name, i)=>{
    const div = document.createElement("div");
    div.className = "colLabel";
    div.dataset.depth = String(i+1);
    div.innerHTML = `<b>N${i+1}</b><span>${name}</span>`;
    colLabelsEl.appendChild(div);
  });
}
function autoLiftLabels(){
  const labels = Array.from(colLabelsEl.querySelectorAll(".colLabel"))
    .filter(el => el.style.display !== "none");
  let maxH = 0;
  for(const el of labels) maxH = Math.max(maxH, el.getBoundingClientRect().height);
  colLabelsEl.style.bottom = `${Math.ceil(maxH + 10)}px`;
}
function positionColumnLabels(){
  if(!ROOT_HIER) return;

  const t = d3.zoomTransform(svg.node());
  setLabelFontByZoom(t.k);
  setNodeFontByZoom(t.k);

  const svgRect  = svg.node().getBoundingClientRect();
  const wrapRect = svgWrapEl.getBoundingClientRect();
  const svgOffsetX = svgRect.left - wrapRect.left;

  const margin = 40;
  const visibleMinX = margin;
  const visibleMaxX = wrapRect.width - margin;

  const activeCount = CURRENT_LEVELS_ACTIVE.length;

  for(let depth=1; depth<=activeCount; depth++){
    const label = colLabelsEl.querySelector(`.colLabel[data-depth="${depth}"]`);
    if(!label) continue;

    const colX = COL_OFFSETS[depth] ?? (depth * 800);
    const colCenterLayoutX = colX + (COL_WIDTHS[depth] || 600) / 2;

    const screenX = t.applyX(colCenterLayoutX);
    const leftPx = svgOffsetX + screenX;

    if(leftPx < visibleMinX || leftPx > visibleMaxX){
      label.style.display = "none";
      continue;
    }
    label.style.display = "";
    label.style.left = `${leftPx}px`;
  }
  autoLiftLabels();
}

let zoom = d3.zoom()
  .scaleExtent([0.25, 3.2])
  .on("zoom", (event)=>{
    g.attr("transform", event.transform);
    positionColumnLabels();
  });
svg.call(zoom);

function wrapText(selection, width){
  selection.each(function(){
    const text = d3.select(this);
    const words = text.text().split(/\s+/).filter(Boolean);
    text.text(null);

    let line = [];
    let lineNumber = 0;
    const lineHeight = 1.15;
    const x = text.attr("x");

    let tspan = text.append("tspan").attr("x", x).attr("y", 0).attr("dy", "0em");

    for (let i=0; i<words.length; i++){
      line.push(words[i]);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > width){
        line.pop();
        tspan.text(line.join(" "));
        line = [words[i]];
        tspan = text.append("tspan")
          .attr("x", x)
          .attr("y", 0)
          .attr("dy", (++lineNumber * lineHeight) + "em")
          .text(words[i]);
      }
    }
  });
}

function linkPath(d){
  const s = d.source, t = d.target;
  const sx = (s._y ?? s.y) + (s._w || (COL_WIDTHS[s.depth] || MIN_W));
  const sy = (s._x ?? s.x);
  const tx = (t._y ?? t.y);
  const ty = (t._x ?? t.x);
  const mx = (sx + tx) / 2;
  return `M${sx},${sy} C${mx},${sy} ${mx},${ty} ${tx},${ty}`;
}
function linkPathBase(d){
  const s = d.source, t = d.target;
  const sx = (s.y) + (s._w || (COL_WIDTHS[s.depth] || MIN_W));
  const sy = s.x;
  const tx = t.y;
  const ty = t.x;
  const mx = (sx + tx) / 2;
  return `M${sx},${sy} C${mx},${sy} ${mx},${ty} ${tx},${ty}`;
}

function clearSelection(){
  g.selectAll(".node").classed("selected", false).classed("path", false);
  g.selectAll(".link").classed("path", false);
}
function applyColumnAlignment(selectedNode){
  if(!selectedNode) return;

  let cur = selectedNode;
  const byDepth = new Map();
  while(cur){
    byDepth.set(cur.depth, cur);
    cur = cur.parent;
  }

  const baseSel = BASE_POS.get(selectedNode);
  const baseline = baseSel ? baseSel.x : selectedNode.x;

  const depthOffsets = new Map();
  ROOT_HIER.descendants().forEach(n=>{
    if(!depthOffsets.has(n.depth)) depthOffsets.set(n.depth, 0);
  });

  for(const [depth, nodeInPath] of byDepth.entries()){
    const b = BASE_POS.get(nodeInPath);
    if(!b) continue;
    depthOffsets.set(depth, baseline - b.x);
  }

  ROOT_HIER.descendants().forEach(n=>{
    const b = BASE_POS.get(n);
    const off = depthOffsets.get(n.depth) || 0;
    n._x = (b ? b.x : n.x) + off;
    n._y = (b ? b.y : n.y);
  });

  g.selectAll(".node")
    .transition().duration(520)
    .attr("transform", d => `translate(${d._y},${d._x})`);

  g.selectAll(".link")
    .transition().duration(520)
    .attr("d", linkPath);
}
function resetToBaseLayout(){
  if(!ROOT_HIER) return;

  ROOT_HIER.descendants().forEach(n=>{
    const b = BASE_POS.get(n);
    n._x = b ? b.x : n.x;
    n._y = b ? b.y : n.y;
  });

  g.selectAll(".node")
    .transition().duration(380)
    .attr("transform", d => `translate(${d.y},${d.x})`);

  g.selectAll(".link")
    .transition().duration(380)
    .attr("d", linkPathBase);
}
function zoomToPath(pathNodesArr){
  if(!pathNodesArr || pathNodesArr.length === 0) return;

  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;

  for(const n of pathNodesArr){
    const x = n._y ?? n.y;
    const y = n._x ?? n.x;
    const w = n._w || (COL_WIDTHS[n.depth] || MIN_W);
    const h = (n.data._h || 180);

    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x + w);
    minY = Math.min(minY, y - h/2);
    maxY = Math.max(maxY, y + h/2);
  }

  const boundsW = maxX - minX;
  const boundsH = maxY - minY;

  const svgW = svg.node().clientWidth;
  const svgH = svg.node().clientHeight;

  const pad = 240;
  const scale = Math.min(3.0, Math.max(0.45,
    0.95 / Math.max(boundsW / (svgW - pad), boundsH / (svgH - pad))
  ));

  const midX = minX + boundsW/2;
  const midY = minY + boundsH/2;

  const translate = [
    svgW/2 - scale * midX,
    svgH/2 - scale * midY
  ];

  svg.transition().duration(650).call(
    zoom.transform,
    d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
  );
}

function render(treeData){
  svg.selectAll("*").remove();
  g = svg.append("g");
  svg.call(zoom);

  ROOT_HIER = d3.hierarchy(treeData);

  // Layout base para vertical
  d3.tree().nodeSize([ROW_GAP, 1])(ROOT_HIER);

  // Crear nodos
  const nodesG = g.selectAll(".node")
    .data(ROOT_HIER.descendants())
    .join("g")
    .attr("class","node");

  nodesG.append("rect")
    .attr("x", 0)
    .attr("y", -80)
    .attr("width", MIN_W)
    .attr("height", 160);

  const titles = nodesG.append("text")
    .attr("class","title")
    .attr("x", PAD_X)
    .attr("y", 0)
    .text(d=>d.data.name);

  // Medir y ajustar tamaños (preferimos horizontal)
  nodesG.each(function(d){
    const node = d3.select(this);
    const textEl = node.select("text.title");

    // Medir una línea
    const bbox1 = textEl.node().getBBox();
    let desiredW = Math.ceil(bbox1.width + PAD_X*2);
    desiredW = Math.max(MIN_W, Math.min(MAX_W, desiredW));
    d._w = desiredW;

    if (desiredW >= MAX_W - 2){
      textEl.text(d.data.name);
      wrapText(textEl, MAX_W - PAD_X*2);
      const bboxWrapped = textEl.node().getBBox();
      let w2 = Math.ceil(Math.min(MAX_W, Math.max(MIN_W, bboxWrapped.width + PAD_X*2)));
      d._w = w2;
    }

    const bboxFinal = textEl.node().getBBox();
    const h = Math.ceil(bboxFinal.height + PAD_Y*2);
    d.data._h = h;

    node.select("rect")
      .attr("y", -(h/2))
      .attr("height", h)
      .attr("width", d._w);

    const centerShiftY = - (bboxFinal.y + bboxFinal.height / 2);
    textEl.attr("transform", `translate(0, ${centerShiftY})`);
  });

  // Ancho máximo por columna
  const maxDepth = d3.max(ROOT_HIER.descendants(), d=>d.depth) || 0;
  COL_WIDTHS = new Array(maxDepth+1).fill(MIN_W);
  ROOT_HIER.descendants().forEach(d=>{
    COL_WIDTHS[d.depth] = Math.max(COL_WIDTHS[d.depth], d._w || MIN_W);
  });

  // offsets acumulados por depth
  COL_OFFSETS = new Array(maxDepth+1).fill(0);
  for(let depth=1; depth<=maxDepth; depth++){
    COL_OFFSETS[depth] = COL_OFFSETS[depth-1] + COL_WIDTHS[depth-1] + COL_GAP;
  }

  // asignar y por columna (fija), normalizar ancho al de la columna
  ROOT_HIER.descendants().forEach(d=>{
    d.y = COL_OFFSETS[d.depth];
    d._x = d.x;
    d._y = d.y;
    d._w = COL_WIDTHS[d.depth];
  });

  nodesG.select("rect").attr("width", d=>COL_WIDTHS[d.depth]);
  nodesG.select("text.title").attr("x", PAD_X);
  nodesG.attr("transform", d => `translate(${d.y},${d.x})`);

  // Links
  g.selectAll(".link")
    .data(ROOT_HIER.links())
    .join("path")
    .attr("class","link")
    .attr("d", linkPathBase);

  // Click en nodo resalta ruta
  nodesG.on("click", (event,d)=>{
    event.stopPropagation();

    clearSelection();
    d3.select(event.currentTarget).classed("selected", true);

    let cur = d;
    const pathNodes = [];
    const pathSet = new Set();
    while(cur){
      pathNodes.push(cur);
      pathSet.add(cur);
      cur = cur.parent;
    }
    pathNodes.reverse();

    g.selectAll(".node").classed("path", n => pathSet.has(n));
    g.selectAll(".link").classed("path", l => pathSet.has(l.target));

    applyColumnAlignment(d);
    zoomToPath(pathNodes);
  });

  svg.on("click", ()=>{
    clearSelection();
    resetToBaseLayout();
  });

  renderColumnLabels(CURRENT_LEVELS_ACTIVE);

  // Fit inicial
  fitToView();
  function fitToView(){
    const bounds = g.node().getBBox();
    if (bounds.width === 0 || bounds.height === 0) return;

    const svgW = svg.node().clientWidth;
    const svgH = svg.node().clientHeight;

    const midX = bounds.x + bounds.width / 2;
    const midY = bounds.y + bounds.height / 2;

    const scale = 0.9 / Math.max(bounds.width / svgW, bounds.height / svgH);
    const translate = [svgW / 2 - scale * midX, svgH / 2 - scale * midY];

    svg.transition().duration(400).call(
      zoom.transform,
      d3.zoomIdentity.translate(translate[0], translate[1]).scale(Math.min(scale, 1.15))
    ).on("end", ()=>{
      positionColumnLabels();
    });
  }

  BASE_POS = new Map();
  ROOT_HIER.descendants().forEach(n=>{
    BASE_POS.set(n, {x:n.x, y:n.y});
  });

  setTimeout(positionColumnLabels, 450);
  setNodeFontByZoom(d3.zoomTransform(svg.node()).k);
}

/* =========================
   ORQUESTACIÓN
========================= */
let ROWS_CACHE = null;

function buildFiltersFromRows(rows){
  const ops = uniqSorted(rows.map(r=>normalizeVal(r["Operaciones vinculadas"])));
  const areas = uniqSorted(rows.map(r=>normalizeVal(r["Área Prioritaria"])));
  const objetivos = uniqSorted(rows.map(r=>normalizeVal(r["Objetivo Estratégico"])));

  fillFilterSelect(fOperacion, ops);
  fillFilterSelect(fArea, areas);
  fillFilterSelect(fObjetivo, objetivos);
}

function renderWithCurrentUI(){
  const levelsActive = getLevelsFromUI();
  CURRENT_LEVELS_ACTIVE = levelsActive;

  const filteredRows = applyRowFilters(ROWS_CACHE);
  const tree = buildTree(filteredRows, levelsActive);
  render(tree);
}

async function main(){
  ROWS_CACHE = await loadRows();
  buildFiltersFromRows(ROWS_CACHE);

  // Render inicial
  renderWithCurrentUI();
}
main();

document.getElementById("renderBtn").onclick = ()=>{
  renderWithCurrentUI();
};

applyFiltersBtn.onclick = ()=>{
  renderWithCurrentUI();
};

window.addEventListener("resize", ()=>{
  positionColumnLabels();
});
</script>
</body>
</html>
