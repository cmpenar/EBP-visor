<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Visor EBP – Árbol interactivo</title>

  <style>
    :root{
      --bg:#f6f8fb;
      --card:#fff;
      --ink:#0f172a;
      --muted:#64748b;
      --line:#cbd5e1;
      --accent:#1d4ed8;

      --labelFont: 14px;
      --topLabelsSpace: 72px;
      --sel:#0b2e4a;

      --nodeFont: 35px;
      --nodeFontMin: 35px;
      --nodeFontMax: 51px;

      --soft:#f1f5f9;
      --softBorder:#cbd5e1;

      /* ✅ FONDO CON IMAGEN EN EL ÁRBOL */
      --treeBgUrl: url("https://raw.githubusercontent.com/cmpenar/EBP-visor/main/Fondo.png");
      --treeBgOpacity: 0.2; /* ajusta 0.10–0.20 */

      /* ✅ Colores del círculo */
      --dotYes:#16a34a;     /* verde */
      --dotNo:#7c3aed;      /* morado */
      --dotUnknown:#94a3b8; /* gris */
    }

    html, body { height: 100%; overflow: hidden; }
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:var(--bg);
      color:var(--ink);
    }

    /* Header */
    header{
      padding:14px 16px;
      background:linear-gradient(180deg,#0b6a7d 0%, #0b3a68 100%);
      color:#fff;
      border-bottom:1px solid rgba(255,255,255,.12);
    }
    .headerCenter{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:18px;
      text-align:center;
      width:100%;
    }
    .logo{
      width:84px;
      height:84px;
      background:transparent;
      border:none;
      overflow:hidden;
      flex:0 0 auto;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .logo img{ width:100%; height:100%; object-fit:contain; display:block; }
    header h1{
      margin:0;
      font-size:52px;
      line-height:1.02;
      font-weight:950;
      letter-spacing:.2px;
    }
    header p{ margin:8px 0 0; font-size:16px; opacity:.92 }

    .wrap{
      display:grid;
      grid-template-columns:360px 1fr;
      gap:12px;
      padding:12px;
      height:calc(100vh - 112px);
      box-sizing:border-box;
      min-height:0;
    }

    /* Panel izquierdo */
    .panel{
      background:var(--card);
      border:1px solid #e2e8f0;
      border-radius:14px;
      box-shadow:0 1px 4px rgba(15,23,42,.06);
      overflow:auto;
      min-height:0;
    }
    .panel .inner{padding:12px;}

    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
    select,button{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid #e2e8f0;
      background:#fff;
      font-size:13px
    }
    button{
      cursor:pointer;
      background:#0ea5e9;
      color:#fff;
      border:0;
      font-weight:800
    }
    button:hover{filter:brightness(.95)}

    .filtersBox{
      margin-top:12px;
      padding:12px;
      border-radius:12px;
      background:var(--soft);
      border:1px dashed var(--softBorder);
    }
    .filtersTitle{
      font-weight:900;
      margin:0 0 10px 0;
      color:#0f172a;
      font-size:14px;
    }
    .filtersBox label{
      margin:10px 0 6px;
      font-size:12px;
      color:#52657b;
    }
    .btnRow{
      display:flex;
      gap:10px;
      margin-top:12px;
    }
    .btnRow button{
      width:100%;
      padding:12px 10px;
      border-radius:12px;
      font-size:14px;
      font-weight:900;
    }
    .btnSecondary{ background:#0b2e4a; }

    /* ✅ Columna derecha: (Árbol arriba + franja inferior) dentro de un "marco" */
#rightFrame{
  background:var(--card);
  border:1px solid #e2e8f0;
  border-radius:14px;
  box-shadow:0 1px 4px rgba(15,23,42,.06);
  overflow:hidden;
  min-width:0;
  min-height:0;
  display:flex;
  flex-direction:column;
}

/* ✅ Contenedor derecho */
#right{
  height:100%;
  width:100%;
  display:flex;
  flex-direction:column;
  min-width:0;
  min-height:0;
}

/* ✅ Área del árbol */
#treeArea{
  flex:1 1 auto;
  padding:12px;
  box-sizing:border-box;
  min-width:0;
  min-height:0;
}

/* ✅ Franja inferior (rectángulo amarillo) */
#bottomBand{
  flex:0 0 auto;
  display:flex;
  gap:12px;
  align-items:stretch;
  padding:12px;
  box-sizing:border-box;
  background:var(--soft);
  border-top:1px solid #e2e8f0;
  min-width:0;
}


    /* ✅ Ejes transversales (ahora en la franja inferior) */
.axesBox{
  flex:1 1 auto;
  background:transparent;
  border:1px dashed var(--softBorder);
  border-radius:12px;
  padding:10px 12px;
  box-shadow:0 1px 4px rgba(15,23,42,.06);
  overflow:hidden;
  display:flex;
  flex-direction:column;
  min-width:0;
}
.axesTitle{
  margin:0 0 10px 0;
  font-size:13px;
  font-weight:950;
  color:#0f172a;
  text-align:left;
}

.axesChips{
  display:flex;
  gap:10px;
  flex:1;
  min-height:0;
  flex-direction:row;
}
.axesChip{
  flex:1;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:10px 12px;
  border-radius:16px;
  background:#eef2ff;
  border:1px solid #e0e7ff;
  color:#3730a3;
  font-weight:600;
  font-size:12px;
  line-height:1.2;
  text-align:center;
  white-space:normal;
  word-break:break-word;
  overflow-wrap:anywhere;
  user-select:none;
  min-height:56px;
}


    /* ✅ Leyenda de Operaciones (solo cuando se renderiza Operaciones vinculadas) */
    .operLegend{
      background:#ffffffcc;
      border:1px solid #e2e8f0;
      border-radius:12px;
      padding:10px 10px;
      margin:0;
      box-shadow:0 1px 4px rgba(15,23,42,.06);
      font-size:11px;
      line-height:1.25;
      color:#0f172a;
    }
    .operLegendRow{
      display:flex;
      align-items:flex-start;
      gap:8px;
      margin:6px 0;
    }
    .operLegendDot{
      width:14px;
      height:14px;
      border-radius:999px;
      flex:0 0 auto;
      margin-top:2px;
      border:1px solid rgba(15,23,42,.15);
    }
    .operYes{ background: var(--dotYes); }
    .operNo { background: var(--dotNo); }

    /* ============================
       ✅ SVG WRAP + FONDO IMAGEN
       ============================ */
    #svgWrap{
      position:relative;
      overflow:hidden;
      height:100%;
      min-width:0;
      min-height:0;
      background:transparent;
      padding-top: var(--topLabelsSpace);
      box-sizing: border-box;
    }

    #svgWrap::before{
      content:"";
      position:absolute;
      inset:0;
      background-image: var(--treeBgUrl);
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      opacity: var(--treeBgOpacity);
      pointer-events:none;
      z-index:0;
    }

    svg{
      width:100%;
      height:100%;
      display:block;
      background:transparent;
      border:1px solid #e2e8f0;
      border-radius:12px;
      box-shadow:0 1px 4px rgba(15,23,42,.06);
      position:relative;
      z-index:1;
    }

    .node rect{
      fill:#fff;
      stroke:#94a3b8;
      stroke-width:1.2;
      rx:14; ry:14;
    }
    .node .title{
      font-size:var(--nodeFont);
      fill:#0f172a;
      font-weight:900;
    }
    .link{ fill:none; stroke:#94a3b8; stroke-width:3; opacity:.85 }
    .node:hover rect{ stroke:var(--accent); stroke-width:2 }

    .node.selected rect,
    .node.path rect{ fill:var(--sel); stroke:var(--sel); }
    .node.selected .title,
    .node.path .title{ fill:#fff; }
    .link.path{ stroke:var(--sel); stroke-width:2.4; opacity:1; }

    .colLabels{
  position:absolute;
  left:0; right:0;
  top:0;
  pointer-events:none;
  z-index:10;
  height:0;
}
    .colLabel{
      position:absolute;
      transform:translateX(-50%);
      display:flex;
      align-items:center;
      gap:8px;
      padding:10px 14px;
      border-radius:12px;
      background:#0f172a;
      color:#fff;
      font-size:var(--labelFont);
      font-weight:900;
      opacity:.93;
      box-shadow:0 6px 16px rgba(15,23,42,.18);
      max-width:420px;
      white-space:normal;
    }
    .colLabel span{ white-space:normal; line-height:1.15; max-width:340px; }

    @media(max-width:1100px){
  #bottomBand{ flex-direction:column; }
  #treeArea{ padding:12px; }
  #svgWrap{ height:70vh; }
}
      .axesBox{ height:auto; }
      #svgWrap{ height:70vh; }
      #rightFrame{ display:block; }
    }
    @media(max-width:980px){
      .wrap{grid-template-columns:1fr; height:auto}
      header h1{font-size:40px}
      header p{font-size:14px}
      .logo{width:70px;height:70px}
    }
  </style>
</head>

<body>
<header>
  <div class="headerCenter">
    <div class="logo" title="BID">
      <img src="https://portales.sre.gob.mx/dgvosc/images/phocagallery/bid.png" alt="Logo BID">
    </div>
    <div>
      <h1>Visor EBP</h1>
      <p>Estrategia de País del BID 2024 -2027 | Costa Rica</p>
    </div>
  </div>
</header>

<div class="wrap">
  <div class="panel">
    <div class="inner">
      <div style="font-size:12px;color:#64748b;line-height:1.35">
        <b>Niveles de lectura</b> (elige el orden de atributos)
      </div>

      <label>Nivel 1</label><select id="lvl1"></select>
      <label>Nivel 2</label><select id="lvl2"></select>
      <label>Nivel 3</label><select id="lvl3"></select>
      <label>Nivel 4</label><select id="lvl4"></select>
      <label>Nivel 5</label><select id="lvl5"></select>

      <div style="height:10px"></div>
      <button id="renderBtn">Renderizar</button>

      <div class="filtersBox">
        <div class="filtersTitle">Filtros</div>

        <label>Operación vinculada</label>
        <select id="fOperacion"></select>

        <label>Área Prioritaria</label>
        <select id="fArea"></select>

        <label>Objetivo Estratégico</label>
        <select id="fObjetivo"></select>

        <div class="btnRow">
          <button id="applyFiltersBtn" class="btnSecondary">Aplicar filtros y renderizar</button>
          <button id="resetBtn">Reestablecer</button>
        </div>
      </div>
    </div>
  </div>

  <div id="rightFrame">
    <div id="right">
      <!-- ✅ Área del árbol -->
      <div id="treeArea">
        <div id="svgWrap">
          <div class="colLabels" id="colLabels"></div>
          <svg id="viz"></svg>
        </div>
      </div>

      <!-- ✅ Franja inferior: Leyenda + Ejes Transversales -->
      <div id="bottomBand">
        <!-- ✅ Leyenda SOLO cuando renderizas Operaciones -->
        <div id="operLegend" class="operLegend" style="display:none; flex:0 0 360px;">
          <div class="operLegendRow">
            <span class="operLegendDot operYes"></span>
            <span>Operaciones aprobadas <b>antes</b> del lanzamiento de la Estrategia 2024-2027</span>
          </div>
          <div class="operLegendRow">
            <span class="operLegendDot operNo"></span>
            <span>Operaciones aprobadas <b>después</b> del lanzamiento de la Estrategia 2024-2027</span>
          </div>
        </div>

        <div class="axesBox" id="axesBox">
          <div class="axesTitle">Ejes Transversales</div>
          <div class="axesChips">
            <div class="axesChip">Género y Diversidad</div>
            <div class="axesChip">Cambio Climático y Descarbonización</div>
            <div class="axesChip">Fortalecimiento Institucional</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
const NONE = "(Ninguno)";
const DEFAULT_LEVELS = ["Área Prioritaria","Objetivo Estratégico", NONE, NONE, NONE];

const LABELS_ALLOWED = [
  "Área Prioritaria",
  "Objetivo Estratégico",
  "Impacto Esperado",
  "Operaciones vinculadas",
  "Cooperaciones técnicas vinculadas",
  "Indicador"
];
const LEVEL_OPTIONS = [NONE, ...LABELS_ALLOWED];

const lvlSelects = ["lvl1","lvl2","lvl3","lvl4","lvl5"].map(id=>document.getElementById(id));
const colLabelsEl = document.getElementById("colLabels");
const svgWrapEl = document.getElementById("svgWrap");

const fOperacion = document.getElementById("fOperacion");
const fArea = document.getElementById("fArea");
const fObjetivo = document.getElementById("fObjetivo");

/* ✅ Leyenda */
const operLegendEl = document.getElementById("operLegend");

function fillSelect(select, options, selected){
  select.innerHTML = "";
  options.forEach(opt=>{
    const o=document.createElement("option");
    o.value=opt; o.textContent=opt;
    if(opt===selected) o.selected=true;
    select.appendChild(o);
  });
}
lvlSelects.forEach((sel,i)=>fillSelect(sel, LEVEL_OPTIONS, DEFAULT_LEVELS[i] || NONE));

function uniqSorted(arr){
  return Array.from(new Set(arr.filter(Boolean))).sort((a,b)=>a.localeCompare(b,'es'));
}

async function loadRows(){
  const res = await fetch("./data.json");
  const data = await res.json();
  return data.rows;
}

const ALL = "(Todos)";
let ROWS_CACHE = null;
let FILTERS = { oper: ALL, area: ALL, obj: ALL };

function applyFilterToRows(rows, f){
  return rows.filter(r=>{
    if(f.oper !== ALL){
      const v = (r["Operaciones vinculadas"] ?? "").toString().trim();
      if(v !== f.oper) return false;
    }
    if(f.area !== ALL){
      const v = (r["Área Prioritaria"] ?? "").toString().trim();
      if(v !== f.area) return false;
    }
    if(f.obj !== ALL){
      const v = (r["Objetivo Estratégico"] ?? "").toString().trim();
      if(v !== f.obj) return false;
    }
    return true;
  });
}

function updateFilterOptions(){
  const base = ROWS_CACHE || [];

  const rowsForOper = applyFilterToRows(base, {oper:ALL, area:FILTERS.area, obj:FILTERS.obj});
  const rowsForArea = applyFilterToRows(base, {oper:FILTERS.oper, area:ALL, obj:FILTERS.obj});
  const rowsForObj  = applyFilterToRows(base, {oper:FILTERS.oper, area:FILTERS.area, obj:ALL});

  const operOpts = [ALL, ...uniqSorted(rowsForOper.map(r=>(r["Operaciones vinculadas"]??"").toString().trim()).filter(v=>v))];
  const areaOpts = [ALL, ...uniqSorted(rowsForArea.map(r=>(r["Área Prioritaria"]??"").toString().trim()).filter(v=>v))];
  const objOpts  = [ALL, ...uniqSorted(rowsForObj.map(r=>(r["Objetivo Estratégico"]??"").toString().trim()).filter(v=>v))];

  if(!operOpts.includes(FILTERS.oper)) FILTERS.oper = ALL;
  if(!areaOpts.includes(FILTERS.area)) FILTERS.area = ALL;
  if(!objOpts.includes(FILTERS.obj)) FILTERS.obj = ALL;

  fillSelect(fOperacion, operOpts, FILTERS.oper);
  fillSelect(fArea, areaOpts, FILTERS.area);
  fillSelect(fObjetivo, objOpts, FILTERS.obj);
}

function resetFilters(){
  FILTERS = {oper:ALL, area:ALL, obj:ALL};
  updateFilterOptions();
}

function getLevelsFromUI(){
  const raw = lvlSelects.map(s=>s.value);
  const active = raw.filter(v => v !== NONE);
  const used = new Set();
  const fixed = [];
  for(const v of active){
    if(!used.has(v)){
      used.add(v);
      fixed.push(v);
    }
  }
  return fixed;
}

function buildTree(rows, levelsActive){
  const root = {name:"EBP Costa Rica 2024-2027", children:[]};

  function getChild(parent, name){
    if(!parent.children) parent.children=[];
    let c = parent.children.find(x=>x.name===name);
    if(!c){ c={name, children:[], _rows:[]}; parent.children.push(c); }
    return c;
  }

  rows.forEach(r=>{
    let p=root;

    if(levelsActive.length === 0){
      root._rows = root._rows || [];
      root._rows.push(r);
      return;
    }

    levelsActive.forEach(lvl=>{
      let v = (r[lvl] ?? "").toString().trim();
      if(!v) v="(Sin dato)";
      p=getChild(p, v);
      p._rows.push(r);
    });
  });

  return root;
}

const svg = d3.select("#viz");
let g = svg.append("g");

let ROOT_HIER = null;
let CURRENT_LEVELS_ACTIVE = [];

/* ✅ Mostrar/Ocultar leyenda SOLO si se renderizan Operaciones */
function updateOperLegendVisibility(){
  const show = CURRENT_LEVELS_ACTIVE.includes("Operaciones vinculadas");
  operLegendEl.style.display = show ? "block" : "none";
}

/* =========================================================
   ✅ ANCHOS POR COLUMNA
   ========================================================= */
const BASE_NODE_WIDTH = 560;
const OBJ_NODE_WIDTH  = 860;
const IMP_NODE_WIDTH  = 860;
const COL_GAP = 240;

let COL_X = [];
let WIDTH_BY_DEPTH = [];

function getDepthOfLevelName(levelName){
  const idx = CURRENT_LEVELS_ACTIVE.indexOf(levelName);
  return idx === -1 ? -1 : (idx + 1);
}

function buildColumnMetrics(maxDepth){
  const objDepth = getDepthOfLevelName("Objetivo Estratégico");
  const impDepth = getDepthOfLevelName("Impacto Esperado");

  WIDTH_BY_DEPTH = Array.from({length: maxDepth + 1}, (_, d) => {
    if(d === 0) return BASE_NODE_WIDTH;
    if(d === objDepth) return OBJ_NODE_WIDTH;
    if(d === impDepth) return IMP_NODE_WIDTH;
    return BASE_NODE_WIDTH;
  });

  COL_X = Array.from({length: maxDepth + 1}, () => 0);
  for(let d=1; d<=maxDepth; d++){
    COL_X[d] = COL_X[d-1] + WIDTH_BY_DEPTH[d-1] + COL_GAP;
  }
}

function nodeWidth(d){
  const depth = (typeof d === "number") ? d : d.depth;
  return WIDTH_BY_DEPTH[depth] ?? BASE_NODE_WIDTH;
}
/* ========================================================= */

let BASE_POS = new Map();

function setNodeFontByZoom(k){
  const base = 30;
  const scaled = base * k;
  const min = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--nodeFontMin")) || 24;
  const max = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--nodeFontMax")) || 44;
  const clamped = Math.max(min, Math.min(max, scaled));
  document.documentElement.style.setProperty("--nodeFont", clamped.toFixed(1) + "px");
}
function setLabelFontByZoom(k){
  const base = 14;
  const scaled = base * k;
  const clamped = Math.max(12, Math.min(22, scaled));
  document.documentElement.style.setProperty("--labelFont", clamped.toFixed(1) + "px");
}

function renderColumnLabels(levelsActive){
  colLabelsEl.innerHTML = "";
  levelsActive.forEach((name, i)=>{
    const div = document.createElement("div");
    div.className = "colLabel";
    div.dataset.depth = String(i+1);
    div.innerHTML = `<span>${name}</span>`;
    colLabelsEl.appendChild(div);
  });
}
function autoLiftLabels(){
  const labels = Array.from(colLabelsEl.querySelectorAll(".colLabel"))
    .filter(el => el.style.display !== "none");

  let maxH = 0;
  for(const el of labels){
    maxH = Math.max(maxH, el.getBoundingClientRect().height);
  }
  colLabelsEl.style.top = "10px";
}

function positionColumnLabels(){
  if(!ROOT_HIER) return;

  const t = d3.zoomTransform(svg.node());
  setLabelFontByZoom(t.k);
  setNodeFontByZoom(t.k);

  const svgRect  = svg.node().getBoundingClientRect();
  const wrapRect = svgWrapEl.getBoundingClientRect();
  const svgOffsetX = svgRect.left - wrapRect.left;

  const margin = 40;
  const visibleMinX = margin;
  const visibleMaxX = wrapRect.width - margin;

  const activeCount = CURRENT_LEVELS_ACTIVE.length;

  for(let depth=1; depth<=activeCount; depth++){
    const label = colLabelsEl.querySelector(`.colLabel[data-depth="${depth}"]`);
    if(!label) continue;

    const colCenterLayoutX = COL_X[depth] + (nodeWidth(depth) / 2);

    const screenX = t.applyX(colCenterLayoutX);
    const leftPx = svgOffsetX + screenX;

    if(leftPx < visibleMinX || leftPx > visibleMaxX){
      label.style.display = "none";
      continue;
    }
    label.style.display = "";
    label.style.left = `${leftPx}px`;
  }

  autoLiftLabels();
}

let zoom = d3.zoom()
  .scaleExtent([0.25, 3.2])
  .on("zoom", (event)=>{
    g.attr("transform", event.transform);
    positionColumnLabels();
  });
svg.call(zoom);

function wrapText(selection, width){
  selection.each(function(){
    const text = d3.select(this);
    const words = text.text().split(/\s+/).filter(Boolean);
    text.text(null);

    let line = [];
    let lineNumber = 0;
    const lineHeight = 1.18;
    const x = text.attr("x");

    let tspan = text.append("tspan").attr("x", x).attr("y", 0).attr("dy", "0em");

    for (let i=0; i<words.length; i++){
      line.push(words[i]);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > width){
        line.pop();
        tspan.text(line.join(" "));
        line = [words[i]];
        tspan = text.append("tspan")
          .attr("x", x)
          .attr("y", 0)
          .attr("dy", (++lineNumber * lineHeight) + "em")
          .text(words[i]);
      }
    }
  });
}

function clearSelection(){
  g.selectAll(".node").classed("selected", false).classed("path", false);
  g.selectAll(".link").classed("path", false);
}

function applyColumnAlignment(selectedNode){
  if(!selectedNode) return;

  let cur = selectedNode;
  const byDepth = new Map();
  while(cur){
    byDepth.set(cur.depth, cur);
    cur = cur.parent;
  }

  const baseSel = BASE_POS.get(selectedNode);
  const baseline = baseSel ? baseSel.x : selectedNode.x;

  const depthOffsets = new Map();
  ROOT_HIER.descendants().forEach(n=>{
    if(!depthOffsets.has(n.depth)) depthOffsets.set(n.depth, 0);
  });

  for(const [depth, nodeInPath] of byDepth.entries()){
    const b = BASE_POS.get(nodeInPath);
    if(!b) continue;
    depthOffsets.set(depth, baseline - b.x);
  }

  ROOT_HIER.descendants().forEach(n=>{
    const b = BASE_POS.get(n);
    const off = depthOffsets.get(n.depth) || 0;
    n._x = (b ? b.x : n.x) + off;
    n._y = (b ? b.y : n.y);
  });

  g.selectAll(".node")
    .transition().duration(520)
    .attr("transform", d => `translate(${d._y},${d._x})`);

  g.selectAll(".link")
    .transition().duration(520)
    .attr("d", d3.linkHorizontal().x(d => d._y).y(d => d._x));
}

function resetToBaseLayout(){
  if(!ROOT_HIER) return;

  ROOT_HIER.descendants().forEach(n=>{
    const b = BASE_POS.get(n);
    n._x = b ? b.x : n.x;
    n._y = b ? b.y : n.y;
  });

  g.selectAll(".node")
    .transition().duration(380)
    .attr("transform", d => `translate(${d.y},${d.x})`);

  g.selectAll(".link")
    .transition().duration(380)
    .attr("d", d3.linkHorizontal().x(d=>d.y).y(d=>d.x));
}

function zoomToPath(pathNodesArr){
  if(!pathNodesArr || pathNodesArr.length === 0) return;

  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;

  for(const n of pathNodesArr){
    const x = n._y ?? n.y;
    const y = n._x ?? n.x;
    const w = nodeWidth(n);
    const h = (n.data._h || 160);

    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x + w);
    minY = Math.min(minY, y - h/2);
    maxY = Math.max(maxY, y + h/2);
  }

  const boundsW = maxX - minX;
  const boundsH = maxY - minY;

  const svgW = svg.node().clientWidth;
  const svgH = svg.node().clientHeight;

  const pad = 220;
  const scale = Math.min(2.6, Math.max(0.45,
    0.95 / Math.max(boundsW / (svgW - pad), boundsH / (svgH - pad))
  ));

  const midX = minX + boundsW/2;
  const midY = minY + boundsH/2;

  const translate = [
    svgW/2 - scale * midX,
    svgH/2 - scale * midY
  ];

  svg.transition().duration(650).call(
    zoom.transform,
    d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
  );
}

function fitToViewLeftAnchored(){
  const bounds = g.node().getBBox();
  if (bounds.width === 0 || bounds.height === 0) return;

  const svgW = svg.node().clientWidth;
  const svgH = svg.node().clientHeight;

  const marginLeft = 40;
  const marginTop  = 30;
  const marginBottom = 60;

  const usableW = Math.max(1, svgW - marginLeft - 40);
  const usableH = Math.max(1, svgH - marginTop - marginBottom);

  const scale = Math.min(1.0, 0.98 / Math.max(bounds.width / usableW, bounds.height / usableH));

  const translateX = marginLeft - scale * bounds.x;
  const centerY = marginTop + usableH/2;
  const boundsMidY = bounds.y + bounds.height/2;
  const translateY = centerY - scale * boundsMidY;

  svg.transition().duration(380).call(
    zoom.transform,
    d3.zoomIdentity.translate(translateX, translateY).scale(scale)
  ).on("end", ()=>{
    positionColumnLabels();
    setNodeFontByZoom(d3.zoomTransform(svg.node()).k);
  });
}

/* =========================================================
   ✅ CÍRCULO POR "Previo EBP 2024-2027" SOLO EN OPERACIONES
   ========================================================= */
const PREV_KEY = "Previo EBP 2024-2027";

/* ✅ Tamaño del círculo */
const DOT_R = 14;
const DOT_PAD_X = 22;
const DOT_CY = 0;

function normPrevValue(v){
  const s = (v ?? "").toString().trim().toUpperCase();
  if(s === "SI" || s === "SÍ") return "SI";
  if(s === "NO") return "NO";
  return "";
}

function computePrevStatusForNode(d){
  const rows = d?.data?._rows || [];
  if(!rows.length) return "UNKNOWN";

  let hasSI = false, hasNO = false;

  for(const r of rows){
    const val = normPrevValue(r[PREV_KEY]);
    if(val === "SI") hasSI = true;
    else if(val === "NO") hasNO = true;
  }

  if(hasSI && !hasNO) return "SI";
  if(hasNO && !hasSI) return "NO";
  if(hasSI && hasNO) return "MIX";
  return "UNKNOWN";
}

function isOperacionNode(d){
  const operDepth = getDepthOfLevelName("Operaciones vinculadas");
  return operDepth !== -1 && d.depth === operDepth;
}

function addPrevDotToOperacionNodes(nodesSelection){
  const opNodes = nodesSelection.filter(d => isOperacionNode(d));

  const defs = svg.select("defs").empty() ? svg.append("defs") : svg.select("defs");

  defs.selectAll("linearGradient#prevMixGrad").data([1]).join("linearGradient")
    .attr("id", "prevMixGrad")
    .attr("x1", "0%").attr("x2", "100%")
    .attr("y1", "0%").attr("y2", "0%")
    .call(g=>{
      g.selectAll("stop").data([
        {o:"0%", c:getComputedStyle(document.documentElement).getPropertyValue("--dotYes").trim() || "#16a34a"},
        {o:"50%", c:getComputedStyle(document.documentElement).getPropertyValue("--dotYes").trim() || "#16a34a"},
        {o:"50%", c:getComputedStyle(document.documentElement).getPropertyValue("--dotNo").trim()  || "#7c3aed"},
        {o:"100%",c:getComputedStyle(document.documentElement).getPropertyValue("--dotNo").trim()  || "#7c3aed"}
      ]).join("stop")
        .attr("offset", d=>d.o)
        .attr("stop-color", d=>d.c);
    });

  opNodes.selectAll("circle.prevDot")
    .data(d => [d], d => d.data.name)
    .join("circle")
    .attr("class", "prevDot")
    .attr("r", DOT_R)
    .attr("cx", d => nodeWidth(d) - DOT_PAD_X)
    .attr("cy", DOT_CY)
    .attr("stroke", "#0f172a")
    .attr("stroke-opacity", 0.15)
    .attr("stroke-width", 1)
    .attr("fill", d => {
      const st = computePrevStatusForNode(d);
      const yes = getComputedStyle(document.documentElement).getPropertyValue("--dotYes").trim() || "#16a34a";
      const no  = getComputedStyle(document.documentElement).getPropertyValue("--dotNo").trim()  || "#7c3aed";
      const unk = getComputedStyle(document.documentElement).getPropertyValue("--dotUnknown").trim() || "#94a3b8";
      if(st === "SI") return yes;
      if(st === "NO") return no;
      if(st === "MIX") return "url(#prevMixGrad)";
      return unk;
    })
    .append("title")
    .text(d => {
      const st = computePrevStatusForNode(d);
      if(st === "SI") return `${PREV_KEY}: SI`;
      if(st === "NO") return `${PREV_KEY}: NO`;
      if(st === "MIX") return `${PREV_KEY}: SI y NO (mezclado)`;
      return `${PREV_KEY}: (Sin dato)`;
    });
}
/* ========================================================= */

function render(treeData){
  updateOperLegendVisibility();

  svg.selectAll("*").remove();
  g = svg.append("g");
  svg.call(zoom);

  ROOT_HIER = d3.hierarchy(treeData);

  const rowGap = 190;
  const treeLayout = d3.tree().nodeSize([rowGap, 1]);
  treeLayout(ROOT_HIER);

  const maxDepth = d3.max(ROOT_HIER.descendants(), d => d.depth) || 0;
  buildColumnMetrics(maxDepth);

  ROOT_HIER.descendants().forEach(d=>{
    d.y = COL_X[d.depth];
  });

  BASE_POS = new Map();
  ROOT_HIER.descendants().forEach(n=>{
    BASE_POS.set(n, {x:n.x, y:n.y});
    n._x = n.x; n._y = n.y;
  });

  g.selectAll(".link")
    .data(ROOT_HIER.links())
    .join("path")
    .attr("class","link")
    .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));

  const nodes = g.selectAll(".node")
    .data(ROOT_HIER.descendants())
    .join("g")
    .attr("class","node")
    .attr("transform", d => `translate(${d.y},${d.x})`)
    .on("click", (event,d)=>{
      event.stopPropagation();

      clearSelection();
      d3.select(event.currentTarget).classed("selected", true);

      let cur = d;
      const pathNodes = [];
      const pathSet = new Set();
      while(cur){
        pathNodes.push(cur);
        pathSet.add(cur);
        cur = cur.parent;
      }
      pathNodes.reverse();

      g.selectAll(".node").classed("path", n => pathSet.has(n));
      g.selectAll(".link").classed("path", l => pathSet.has(l.target));

      applyColumnAlignment(d);
      zoomToPath(pathNodes);
    });

  svg.on("click", ()=>{
    clearSelection();
    resetToBaseLayout();
  });

  nodes.append("rect")
    .attr("x", 0)
    .attr("y", -60)
    .attr("width", d => nodeWidth(d))
    .attr("height", 120);

  const title = nodes.append("text")
    .attr("class","title")
    .attr("x", 20)
    .attr("y", 0)
    .text(d=>d.data.name);

  title.each(function(d){
    const w = nodeWidth(d) - 36;
    wrapText(d3.select(this), w);
  });

  nodes.each(function(d){
    const node = d3.select(this);
    const textEl = node.select("text.title").node();
    const bbox = textEl.getBBox();

    const padY = 38;
    const h = bbox.height + padY * 2;
    d.data._h = h;

    node.select("rect")
      .attr("y", -(h/2))
      .attr("height", h);

    const centerShiftY = - (bbox.y + bbox.height / 2);
    node.select("text.title")
      .attr("transform", `translate(0, ${centerShiftY})`);
  });

  addPrevDotToOperacionNodes(nodes);

  renderColumnLabels(CURRENT_LEVELS_ACTIVE);
  fitToViewLeftAnchored();

  setTimeout(positionColumnLabels, 450);
  setTimeout(()=>setNodeFontByZoom(d3.zoomTransform(svg.node()).k), 480);
}

async function main(){
  ROWS_CACHE = await loadRows();
  resetFilters();

  CURRENT_LEVELS_ACTIVE = getLevelsFromUI();
  const filtered = applyFilterToRows(ROWS_CACHE, FILTERS);
  const tree = buildTree(filtered, CURRENT_LEVELS_ACTIVE);
  render(tree);
}
main();

document.getElementById("renderBtn").onclick = ()=>{
  CURRENT_LEVELS_ACTIVE = getLevelsFromUI();
  const filtered = applyFilterToRows(ROWS_CACHE, FILTERS);
  const tree = buildTree(filtered, CURRENT_LEVELS_ACTIVE);
  render(tree);
};

document.getElementById("applyFiltersBtn").onclick = ()=>{
  CURRENT_LEVELS_ACTIVE = getLevelsFromUI();
  const filtered = applyFilterToRows(ROWS_CACHE, FILTERS);
  const tree = buildTree(filtered, CURRENT_LEVELS_ACTIVE);
  render(tree);
};

document.getElementById("resetBtn").onclick = ()=>{
  resetFilters();
  clearSelection();
  resetToBaseLayout();

  CURRENT_LEVELS_ACTIVE = getLevelsFromUI();
  const tree = buildTree(ROWS_CACHE, CURRENT_LEVELS_ACTIVE);
  render(tree);
};

fOperacion.addEventListener("change", ()=>{
  FILTERS.oper = fOperacion.value;
  updateFilterOptions();
});
fArea.addEventListener("change", ()=>{
  FILTERS.area = fArea.value;
  updateFilterOptions();
});
fObjetivo.addEventListener("change", ()=>{
  FILTERS.obj = fObjetivo.value;
  updateFilterOptions();
});

window.addEventListener("resize", ()=>{
  positionColumnLabels();
});
</script>
</body>
</html>

