<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Visor EBP – Árbol interactivo</title>

  <style>
    :root{
      --bg:#f6f8fb;
      --card:#fff;
      --ink:#0f172a;
      --muted:#64748b;
      --line:#cbd5e1;
      --accent:#1d4ed8;

      --labelFont: 14px;
      --sel:#0b2e4a;

      --nodeFont: 30px;
      --nodeFontMin: 24px;
      --nodeFontMax: 44px;

      --soft:#f1f5f9;
      --softBorder:#cbd5e1;
    }

    html, body { height: 100%; overflow: hidden; }
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:var(--bg);
      color:var(--ink);
    }

    /* Header */
    header{
      padding:14px 16px;
      background:linear-gradient(180deg,#0b6a7d 0%, #0b3a68 100%);
      color:#fff;
      border-bottom:1px solid rgba(255,255,255,.12);
    }
    .headerCenter{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:18px;
      text-align:center;
      width:100%;
    }
    .logo{
      width:84px;
      height:84px;
      background:transparent;
      border:none;
      overflow:hidden;
      flex:0 0 auto;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .logo img{ width:100%; height:100%; object-fit:contain; display:block; }
    header h1{
      margin:0;
      font-size:52px;
      line-height:1.02;
      font-weight:950;
      letter-spacing:.2px;
    }
    header p{ margin:8px 0 0; font-size:16px; opacity:.92 }

    .wrap{
      display:grid;
      grid-template-columns:360px 1fr;
      gap:12px;
      padding:12px;
      height:calc(100vh - 112px);
      box-sizing:border-box;
      min-height:0;
    }

    /* Panel izquierdo */
    .panel{
      background:var(--card);
      border:1px solid #e2e8f0;
      border-radius:14px;
      box-shadow:0 1px 4px rgba(15,23,42,.06);
      overflow:auto;
      min-height:0;
    }
    .panel .inner{padding:12px;}

    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
    select,button{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid #e2e8f0;
      background:#fff;
      font-size:13px
    }
    button{
      cursor:pointer;
      background:#0ea5e9;
      color:#fff;
      border:0;
      font-weight:800
    }
    button:hover{filter:brightness(.95)}

    .filtersBox{
      margin-top:12px;
      padding:12px;
      border-radius:12px;
      background:var(--soft);
      border:1px dashed var(--softBorder);
    }
    .filtersTitle{
      font-weight:900;
      margin:0 0 10px 0;
      color:#0f172a;
      font-size:14px;
    }
    .filtersBox label{
      margin:10px 0 6px;
      font-size:12px;
      color:#52657b;
    }
    .btnRow{
      display:flex;
      gap:10px;
      margin-top:12px;
    }
    .btnRow button{
      width:100%;
      padding:12px 10px;
      border-radius:12px;
      font-size:14px;
      font-weight:900;
    }
    .btnSecondary{ background:#0b2e4a; }

    /* ✅ Columna derecha: (Ejes | Árbol) dentro de un "marco" */
    #rightFrame{
      background:var(--card);
      border:1px solid #e2e8f0;
      border-radius:14px;
      box-shadow:0 1px 4px rgba(15,23,42,.06);
      overflow:hidden;
      min-width:0;
      min-height:0;
      display:flex;
    }

    /* ✅ Hacemos "Niveles" con el MISMO ancho que "Ejes" */
    #right{
      display:grid;
      grid-template-columns: 170px 1fr; /* ✅ ancho único para ejes */
      gap:12px;
      height:100%;
      width:100%;
      padding:12px;
      box-sizing:border-box;
      min-width:0;
      min-height:0;
    }

    /* ✅ Caja de ejes (misma estética que filtros) */
    .axesBox{
      height:100%;
      background:var(--soft);
      border:1px dashed var(--softBorder);
      border-radius:12px;
      padding:12px;
      box-shadow:0 1px 4px rgba(15,23,42,.06);
      overflow:hidden; /* ✅ que no se coma al mapa */
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .axesTitle{
      margin:0 0 10px 0;
      font-size:14px;
      font-weight:950;
      color:#0f172a;
    }

    /* ✅ distribuir 3 ejes en altura disponible, iguales */
    .axesChips{
      display:flex;
      flex-direction:column;
      gap:10px;
      flex:1;
      min-height:0;
    }
    .axesChip{
      flex:1;                 /* ✅ los 3 iguales */
      display:flex;
      align-items:center;     /* ✅ centrado vertical */
      justify-content:center; /* ✅ centrado horizontal */
      padding:10px 12px;
      border-radius:16px;
      background:#eef2ff;
      border:1px solid #e0e7ff;
      color:#3730a3;
      font-weight:500;        /* ✅ sin negrita */
      font-size:14px;
      line-height:1.2;
      text-align:center;
      white-space:normal;
      word-break:break-word;
      overflow-wrap:anywhere;
      user-select:none;
    }

    /* SVG */
    #svgWrap{ position:relative; overflow:hidden; height:100%; min-width:0; min-height:0; }
    svg{
      width:100%;
      height:100%;
      display:block;
      background:var(--card);
      border:1px solid #e2e8f0;
      border-radius:12px; /* ✅ adentro del marco */
      box-shadow:0 1px 4px rgba(15,23,42,.06);
    }

    .node rect{
      fill:#fff;
      stroke:#94a3b8;
      stroke-width:1.2;
      rx:14; ry:14;
    }
    .node .title{
      font-size:var(--nodeFont);
      fill:#0f172a;
      font-weight:900;
    }
    .link{ fill:none; stroke:#94a3b8; stroke-width:1.2; opacity:.85 }
    .node:hover rect{ stroke:var(--accent); stroke-width:2 }

    .node.selected rect,
    .node.path rect{ fill:var(--sel); stroke:var(--sel); }
    .node.selected .title,
    .node.path .title{ fill:#fff; }
    .link.path{ stroke:var(--sel); stroke-width:2.4; opacity:1; }

    .colLabels{
      position:absolute;
      left:0; right:0;
      bottom:0;
      pointer-events:none;
      z-index:10;
      height:0;
    }
    .colLabel{
      position:absolute;
      transform:translateX(-50%);
      display:flex;
      align-items:center;
      gap:8px;
      padding:10px 14px;
      border-radius:12px;
      background:#0f172a;
      color:#fff;
      font-size:var(--labelFont);
      font-weight:900;
      opacity:.93;
      box-shadow:0 6px 16px rgba(15,23,42,.18);
      max-width:420px;
      white-space:normal;
    }
    .colLabel b{
      background:rgba(255,255,255,.18);
      padding:2px 10px;
      border-radius:999px;
      font-size:calc(var(--labelFont) - 1px);
      font-weight:900;
      white-space:nowrap;
    }
    .colLabel span{ white-space:normal; line-height:1.15; max-width:340px; }

    @media(max-width:1100px){
      #right{ grid-template-columns: 1fr; }
      .axesBox{ height:auto; }
      #svgWrap{ height:70vh; }
      #rightFrame{ display:block; }
    }
    @media(max-width:980px){
      .wrap{grid-template-columns:1fr; height:auto}
      header h1{font-size:40px}
      header p{font-size:14px}
      .logo{width:70px;height:70px}
    }
  </style>
</head>

<body>
<header>
  <div class="headerCenter">
    <div class="logo" title="BID">
      <img src="https://portales.sre.gob.mx/dgvosc/images/phocagallery/bid.png" alt="Logo BID">
    </div>
    <div>
      <h1>Visor EBP</h1>
      <p>Estrategia de País del BID 2024 -2027 | Costa Rica</p>
    </div>
  </div>
</header>

<div class="wrap">
  <!-- ✅ IZQUIERDA: Niveles + Filtros -->
  <div class="panel">
    <div class="inner">
      <div style="font-size:12px;color:#64748b;line-height:1.35">
        <b>Niveles de lectura</b> (elige el orden de atributos)
      </div>

      <label>Nivel 1</label><select id="lvl1"></select>
      <label>Nivel 2</label><select id="lvl2"></select>
      <label>Nivel 3</label><select id="lvl3"></select>
      <label>Nivel 4</label><select id="lvl4"></select>
      <label>Nivel 5</label><select id="lvl5"></select>

      <div style="height:10px"></div>
      <button id="renderBtn">Renderizar</button>

      <div class="filtersBox">
        <div class="filtersTitle">Filtros</div>

        <label>Operación vinculada</label>
        <select id="fOperacion"></select>

        <label>Área Prioritaria</label>
        <select id="fArea"></select>

        <label>Objetivo Estratégico</label>
        <select id="fObjetivo"></select>

        <div class="btnRow">
          <button id="applyFiltersBtn" class="btnSecondary">Aplicar filtros y renderizar</button>
          <button id="resetBtn">Reestablecer</button>
        </div>
      </div>
    </div>
  </div>

  <!-- ✅ DERECHA: Marco agrupado (Ejes + Árbol) -->
  <div id="rightFrame">
    <div id="right">
      <div class="axesBox" id="axesBox">
        <div class="axesTitle">Ejes transversales</div>
        <div class="axesChips">
          <div class="axesChip">Género y diversidad</div>
          <div class="axesChip">Cambio climático y Descarbonización</div>
          <div class="axesChip">Fortalecimiento Institucional</div>
        </div>
      </div>

      <div id="svgWrap">
        <div class="colLabels" id="colLabels"></div>
        <svg id="viz"></svg>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
const NONE = "(Ninguno)";
const DEFAULT_LEVELS = ["Área Prioritaria","Objetivo Estratégico", NONE, NONE, NONE];

const LABELS_ALLOWED = [
  "Área Prioritaria",
  "Objetivo Estratégico",
  "Impacto Esperado",
  "Operaciones vinculadas",
  "Cooperaciones técnicas vinculadas",
  "Indicador"
];
const LEVEL_OPTIONS = [NONE, ...LABELS_ALLOWED];

const lvlSelects = ["lvl1","lvl2","lvl3","lvl4","lvl5"].map(id=>document.getElementById(id));
const colLabelsEl = document.getElementById("colLabels");
const svgWrapEl = document.getElementById("svgWrap");

const fOperacion = document.getElementById("fOperacion");
const fArea = document.getElementById("fArea");
const fObjetivo = document.getElementById("fObjetivo");

function fillSelect(select, options, selected){
  select.innerHTML = "";
  options.forEach(opt=>{
    const o=document.createElement("option");
    o.value=opt; o.textContent=opt;
    if(opt===selected) o.selected=true;
    select.appendChild(o);
  });
}
lvlSelects.forEach((sel,i)=>fillSelect(sel, LEVEL_OPTIONS, DEFAULT_LEVELS[i] || NONE));

function uniqSorted(arr){
  return Array.from(new Set(arr.filter(Boolean))).sort((a,b)=>a.localeCompare(b,'es'));
}

async function loadRows(){
  const res = await fetch("./data.json");
  const data = await res.json();
  return data.rows;
}

const ALL = "(Todos)";
let ROWS_CACHE = null;
let FILTERS = { oper: ALL, area: ALL, obj: ALL };

function applyFilterToRows(rows, f){
  return rows.filter(r=>{
    if(f.oper !== ALL){
      const v = (r["Operaciones vinculadas"] ?? "").toString().trim();
      if(v !== f.oper) return false;
    }
    if(f.area !== ALL){
      const v = (r["Área Prioritaria"] ?? "").toString().trim();
      if(v !== f.area) return false;
    }
    if(f.obj !== ALL){
      const v = (r["Objetivo Estratégico"] ?? "").toString().trim();
      if(v !== f.obj) return false;
    }
    return true;
  });
}

function updateFilterOptions(){
  const base = ROWS_CACHE || [];

  const rowsForOper = applyFilterToRows(base, {oper:ALL, area:FILTERS.area, obj:FILTERS.obj});
  const rowsForArea = applyFilterToRows(base, {oper:FILTERS.oper, area:ALL, obj:FILTERS.obj});
  const rowsForObj  = applyFilterToRows(base, {oper:FILTERS.oper, area:FILTERS.area, obj:ALL});

  const operOpts = [ALL, ...uniqSorted(rowsForOper.map(r=>(r["Operaciones vinculadas"]??"").toString().trim()).filter(v=>v))];
  const areaOpts = [ALL, ...uniqSorted(rowsForArea.map(r=>(r["Área Prioritaria"]??"").toString().trim()).filter(v=>v))];
  const objOpts  = [ALL, ...uniqSorted(rowsForObj.map(r=>(r["Objetivo Estratégico"]??"").toString().trim()).filter(v=>v))];

  if(!operOpts.includes(FILTERS.oper)) FILTERS.oper = ALL;
  if(!areaOpts.includes(FILTERS.area)) FILTERS.area = ALL;
  if(!objOpts.includes(FILTERS.obj)) FILTERS.obj = ALL;

  fillSelect(fOperacion, operOpts, FILTERS.oper);
  fillSelect(fArea, areaOpts, FILTERS.area);
  fillSelect(fObjetivo, objOpts, FILTERS.obj);
}

function resetFilters(){
  FILTERS = {oper:ALL, area:ALL, obj:ALL};
  updateFilterOptions();
}

function getLevelsFromUI(){
  const raw = lvlSelects.map(s=>s.value);
  const active = raw.filter(v => v !== NONE);
  const used = new Set();
  const fixed = [];
  for(const v of active){
    if(!used.has(v)){
      used.add(v);
      fixed.push(v);
    }
  }
  return fixed;
}

function buildTree(rows, levelsActive){
  const root = {name:"EBP Costa Rica 2024-2027", children:[]};

  function getChild(parent, name){
    if(!parent.children) parent.children=[];
    let c = parent.children.find(x=>x.name===name);
    if(!c){ c={name, children:[], _rows:[]}; parent.children.push(c); }
    return c;
  }

  rows.forEach(r=>{
    let p=root;

    if(levelsActive.length === 0){
      root._rows = root._rows || [];
      root._rows.push(r);
      return;
    }

    levelsActive.forEach(lvl=>{
      let v = (r[lvl] ?? "").toString().trim();
      if(!v) v="(Sin dato)";
      p=getChild(p, v);
      p._rows.push(r);
    });
  });

  return root;
}

const svg = d3.select("#viz");
let g = svg.append("g");

let ROOT_HIER = null;
let CURRENT_LEVELS_ACTIVE = [];
let NODE_CARD_WIDTH = 560;
let COL_STEP_X = 780;

let BASE_POS = new Map();

function setNodeFontByZoom(k){
  const base = 30;
  const scaled = base * k;
  const min = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--nodeFontMin")) || 24;
  const max = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--nodeFontMax")) || 44;
  const clamped = Math.max(min, Math.min(max, scaled));
  document.documentElement.style.setProperty("--nodeFont", clamped.toFixed(1) + "px");
}
function setLabelFontByZoom(k){
  const base = 14;
  const scaled = base * k;
  const clamped = Math.max(12, Math.min(22, scaled));
  document.documentElement.style.setProperty("--labelFont", clamped.toFixed(1) + "px");
}

function renderColumnLabels(levelsActive){
  colLabelsEl.innerHTML = "";
  levelsActive.forEach((name, i)=>{
    const div = document.createElement("div");
    div.className = "colLabel";
    div.dataset.depth = String(i+1);
    div.innerHTML = `<b>N${i+1}</b><span>${name}</span>`;
    colLabelsEl.appendChild(div);
  });
}
function autoLiftLabels(){
  const labels = Array.from(colLabelsEl.querySelectorAll(".colLabel"))
    .filter(el => el.style.display !== "none");

  let maxH = 0;
  for(const el of labels){
    maxH = Math.max(maxH, el.getBoundingClientRect().height);
  }
  colLabelsEl.style.bottom = `${Math.ceil(maxH + 10)}px`;
}
function positionColumnLabels(){
  if(!ROOT_HIER) return;

  const t = d3.zoomTransform(svg.node());
  setLabelFontByZoom(t.k);
  setNodeFontByZoom(t.k);

  const svgRect  = svg.node().getBoundingClientRect();
  const wrapRect = svgWrapEl.getBoundingClientRect();
  const svgOffsetX = svgRect.left - wrapRect.left;

  const margin = 40;
  const visibleMinX = margin;
  const visibleMaxX = wrapRect.width - margin;

  const activeCount = CURRENT_LEVELS_ACTIVE.length;

  for(let depth=1; depth<=activeCount; depth++){
    const label = colLabelsEl.querySelector(`.colLabel[data-depth="${depth}"]`);
    if(!label) continue;

    const colCenterLayoutX = (depth * COL_STEP_X) + (NODE_CARD_WIDTH / 2);
    const screenX = t.applyX(colCenterLayoutX);
    const leftPx = svgOffsetX + screenX;

    if(leftPx < visibleMinX || leftPx > visibleMaxX){
      label.style.display = "none";
      continue;
    }
    label.style.display = "";
    label.style.left = `${leftPx}px`;
  }

  autoLiftLabels();
}

let zoom = d3.zoom()
  .scaleExtent([0.25, 3.2])
  .on("zoom", (event)=>{
    g.attr("transform", event.transform);
    positionColumnLabels();
  });
svg.call(zoom);

function wrapText(selection, width){
  selection.each(function(){
    const text = d3.select(this);
    const words = text.text().split(/\s+/).filter(Boolean);
    text.text(null);

    let line = [];
    let lineNumber = 0;
    const lineHeight = 1.18;
    const x = text.attr("x");

    let tspan = text.append("tspan").attr("x", x).attr("y", 0).attr("dy", "0em");

    for (let i=0; i<words.length; i++){
      line.push(words[i]);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > width){
        line.pop();
        tspan.text(line.join(" "));
        line = [words[i]];
        tspan = text.append("tspan")
          .attr("x", x)
          .attr("y", 0)
          .attr("dy", (++lineNumber * lineHeight) + "em")
          .text(words[i]);
      }
    }
  });
}

function clearSelection(){
  g.selectAll(".node").classed("selected", false).classed("path", false);
  g.selectAll(".link").classed("path", false);
}

function applyColumnAlignment(selectedNode){
  if(!selectedNode) return;

  let cur = selectedNode;
  const byDepth = new Map();
  while(cur){
    byDepth.set(cur.depth, cur);
    cur = cur.parent;
  }

  const baseSel = BASE_POS.get(selectedNode);
  const baseline = baseSel ? baseSel.x : selectedNode.x;

  const depthOffsets = new Map();
  ROOT_HIER.descendants().forEach(n=>{
    if(!depthOffsets.has(n.depth)) depthOffsets.set(n.depth, 0);
  });

  for(const [depth, nodeInPath] of byDepth.entries()){
    const b = BASE_POS.get(nodeInPath);
    if(!b) continue;
    depthOffsets.set(depth, baseline - b.x);
  }

  ROOT_HIER.descendants().forEach(n=>{
    const b = BASE_POS.get(n);
    const off = depthOffsets.get(n.depth) || 0;
    n._x = (b ? b.x : n.x) + off;
    n._y = (b ? b.y : n.y);
  });

  g.selectAll(".node")
    .transition().duration(520)
    .attr("transform", d => `translate(${d._y},${d._x})`);

  g.selectAll(".link")
    .transition().duration(520)
    .attr("d", d3.linkHorizontal().x(d => d._y).y(d => d._x));
}

function resetToBaseLayout(){
  if(!ROOT_HIER) return;

  ROOT_HIER.descendants().forEach(n=>{
    const b = BASE_POS.get(n);
    n._x = b ? b.x : n.x;
    n._y = b ? b.y : n.y;
  });

  g.selectAll(".node")
    .transition().duration(380)
    .attr("transform", d => `translate(${d.y},${d.x})`);

  g.selectAll(".link")
    .transition().duration(380)
    .attr("d", d3.linkHorizontal().x(d=>d.y).y(d=>d.x));
}

function zoomToPath(pathNodesArr){
  if(!pathNodesArr || pathNodesArr.length === 0) return;

  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;

  for(const n of pathNodesArr){
    const x = n._y ?? n.y;
    const y = n._x ?? n.x;
    const w = NODE_CARD_WIDTH;
    const h = (n.data._h || 160);

    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x + w);
    minY = Math.min(minY, y - h/2);
    maxY = Math.max(maxY, y + h/2);
  }

  const boundsW = maxX - minX;
  const boundsH = maxY - minY;

  const svgW = svg.node().clientWidth;
  const svgH = svg.node().clientHeight;

  const pad = 220;
  const scale = Math.min(2.6, Math.max(0.45,
    0.95 / Math.max(boundsW / (svgW - pad), boundsH / (svgH - pad))
  ));

  const midX = minX + boundsW/2;
  const midY = minY + boundsH/2;

  const translate = [
    svgW/2 - scale * midX,
    svgH/2 - scale * midY
  ];

  svg.transition().duration(650).call(
    zoom.transform,
    d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
  );
}

function fitToViewLeftAnchored(){
  const bounds = g.node().getBBox();
  if (bounds.width === 0 || bounds.height === 0) return;

  const svgW = svg.node().clientWidth;
  const svgH = svg.node().clientHeight;

  const marginLeft = 40;
  const marginTop  = 30;
  const marginBottom = 60;

  const usableW = Math.max(1, svgW - marginLeft - 40);
  const usableH = Math.max(1, svgH - marginTop - marginBottom);

  const scale = Math.min(1.0, 0.98 / Math.max(bounds.width / usableW, bounds.height / usableH));

  const translateX = marginLeft - scale * bounds.x;
  const centerY = marginTop + usableH/2;
  const boundsMidY = bounds.y + bounds.height/2;
  const translateY = centerY - scale * boundsMidY;

  svg.transition().duration(380).call(
    zoom.transform,
    d3.zoomIdentity.translate(translateX, translateY).scale(scale)
  ).on("end", ()=>{
    positionColumnLabels();
    setNodeFontByZoom(d3.zoomTransform(svg.node()).k);
  });
}

function render(treeData){
  svg.selectAll("*").remove();
  g = svg.append("g");
  svg.call(zoom);

  ROOT_HIER = d3.hierarchy(treeData);

  const colGap = 240;
  COL_STEP_X = NODE_CARD_WIDTH + colGap;
  const textWrapWidth = NODE_CARD_WIDTH - 36;

  const rowGap = 190;
  const treeLayout = d3.tree().nodeSize([rowGap, 1]);
  treeLayout(ROOT_HIER);

  ROOT_HIER.descendants().forEach(d=>{
    d.y = d.depth * COL_STEP_X;
  });

  BASE_POS = new Map();
  ROOT_HIER.descendants().forEach(n=>{
    BASE_POS.set(n, {x:n.x, y:n.y});
    n._x = n.x; n._y = n.y;
  });

  g.selectAll(".link")
    .data(ROOT_HIER.links())
    .join("path")
    .attr("class","link")
    .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));

  const nodes = g.selectAll(".node")
    .data(ROOT_HIER.descendants())
    .join("g")
    .attr("class","node")
    .attr("transform", d => `translate(${d.y},${d.x})`)
    .on("click", (event,d)=>{
      event.stopPropagation();

      clearSelection();
      d3.select(event.currentTarget).classed("selected", true);

      let cur = d;
      const pathNodes = [];
      const pathSet = new Set();
      while(cur){
        pathNodes.push(cur);
        pathSet.add(cur);
        cur = cur.parent;
      }
      pathNodes.reverse();

      g.selectAll(".node").classed("path", n => pathSet.has(n));
      g.selectAll(".link").classed("path", l => pathSet.has(l.target));

      applyColumnAlignment(d);
      zoomToPath(pathNodes);
    });

  svg.on("click", ()=>{
    clearSelection();
    resetToBaseLayout();
  });

  nodes.append("rect")
    .attr("x", 0)
    .attr("y", -60)
    .attr("width", NODE_CARD_WIDTH)
    .attr("height", 120);

  const title = nodes.append("text")
    .attr("class","title")
    .attr("x", 20)
    .attr("y", 0)
    .text(d=>d.data.name);

  title.call(wrapText, textWrapWidth);

  nodes.each(function(d){
    const node = d3.select(this);
    const textEl = node.select("text.title").node();
    const bbox = textEl.getBBox();

    const padY = 38;
    const h = bbox.height + padY * 2;
    d.data._h = h;

    node.select("rect")
      .attr("y", -(h/2))
      .attr("height", h);

    const centerShiftY = - (bbox.y + bbox.height / 2);
    node.select("text.title")
      .attr("transform", `translate(0, ${centerShiftY})`);
  });

  renderColumnLabels(CURRENT_LEVELS_ACTIVE);
  fitToViewLeftAnchored();

  setTimeout(positionColumnLabels, 450);
  setTimeout(()=>setNodeFontByZoom(d3.zoomTransform(svg.node()).k), 480);
}

async function main(){
  ROWS_CACHE = await loadRows();
  resetFilters();

  CURRENT_LEVELS_ACTIVE = getLevelsFromUI();
  const filtered = applyFilterToRows(ROWS_CACHE, FILTERS);
  const tree = buildTree(filtered, CURRENT_LEVELS_ACTIVE);
  render(tree);
}
main();

document.getElementById("renderBtn").onclick = ()=>{
  CURRENT_LEVELS_ACTIVE = getLevelsFromUI();
  const filtered = applyFilterToRows(ROWS_CACHE, FILTERS);
  const tree = buildTree(filtered, CURRENT_LEVELS_ACTIVE);
  render(tree);
};

document.getElementById("applyFiltersBtn").onclick = ()=>{
  CURRENT_LEVELS_ACTIVE = getLevelsFromUI();
  const filtered = applyFilterToRows(ROWS_CACHE, FILTERS);
  const tree = buildTree(filtered, CURRENT_LEVELS_ACTIVE);
  render(tree);
};

document.getElementById("resetBtn").onclick = ()=>{
  resetFilters();
  clearSelection();
  resetToBaseLayout();

  CURRENT_LEVELS_ACTIVE = getLevelsFromUI();
  const tree = buildTree(ROWS_CACHE, CURRENT_LEVELS_ACTIVE);
  render(tree);
};

fOperacion.addEventListener("change", ()=>{
  FILTERS.oper = fOperacion.value;
  updateFilterOptions();
});
fArea.addEventListener("change", ()=>{
  FILTERS.area = fArea.value;
  updateFilterOptions();
});
fObjetivo.addEventListener("change", ()=>{
  FILTERS.obj = fObjetivo.value;
  updateFilterOptions();
});

window.addEventListener("resize", ()=>{
  positionColumnLabels();
});
</script>
</body>
</html>



